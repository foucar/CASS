/**
@page developer Developer information

CASS has two basic parts the input and analyze. Where the input part gets the data
from either file or shared memory and the analyze part will analyze the data.
Both of them are threaded, where the input is always just one thread and the
analyze part consists of more threads. The linkage between the input threads
and the analysis thread is done by cass::RingBuffer. This is a buffer that
contains the amount of cass::CASSEvent elements that can be chosen by setting
cass::RingBufferSize. It allows to retrieve elements that should be filled with
new data and elements whos contents should be analyzed.


@section input Input part of CASS
Both inputs will do the follwing tasks after they retrieved the data from LCLS:
- get fillable (empty) cass::CASSEvent element from cass::RingBuffer
- convert LCLS data to cass::CASSEvent data and fill the later with the data
- put cass::CASSEvent back into cass::Ringbuffer

To convert the data the cass::FormatConverter singleton is used. This will
iterate through the LCLS datagram and call the right cass::ConversionBackend
object that will convert the xtc data to cass::CASSEvent data. The user can
select what part of the data he wants to have converted by setting up which
converters he wants to use. Please refer to the documentation of
cass::FormatConverter and the converters for details.

@section offline_input Offline input of CASS
The input part that will read the data from file in offline mode is handled by
the class cass::FileInput. This just parses the input file containing the file
names to analyze, put them into string list and then goes through that list.
For each file it will retrieve an event and convert the data to cass::CASSEvent
object. The later was retrieved from the cass::RingBuffer and then later put back
into it.


@section online_input Online input of CASS
In the online mode the input part will read the data from the LCLS shared memory.
The class that does that is cass::SharedMemoryInput. It derives from the
Pds::XtcMonitorClient class provided by LCLS. This class will do all the
communication between the shared memory and CASS. Once it retrieved new data
(in LCLS speach this is called datagram) it will call the overwritten
cass::SharedMemoryInput::processDgram() member. Here the datagram will be
converted to a cass::CASSEvent which is retrieved from the cass::RingBuffer
before. After that it is put back into the cass::RingBuffer.



@section analysis Analysis part of CASS
The analysis part is done by multiple threads. One can say how many analysis
threads should be present by modifying the cass::NbrOfWorkers variable. Each
analysis thread is a cass::Worker object, which are handled by the cass::Workers
object. Each one of the cass::Worker objects will do the following until it is
told to quit:
- retrieve an analysable (non empty) cass::CASSEvent element from cass::RingBuffer
- pre analyze the cass::CASSEvent element using the cass::Analyzer singleton
- post analyze the cass::CASSEvent element using the cass::PostProcessors
  singleton.
- put the event back to the ringbuffer to be refilled again.

The cass::Analyzer singleton will pass the cass event to all user selected pre
analyzers to pre process the data. The cass::PostProcessor will pass the event
to all user defined postprocessors the be postprocessed. For further details on
how to select what postprocessors should run please see section @ref inifilesetup.
Further details about the analyzers can be found in the documentation of
cass::Analyzer and the analyzers it handles.

@section communication Communicating with CASS
CASS is using SOAP to communicate with the viewers. The class that handles these
communication is cass::SoapServer. It uses a cass::HistogramGetter object to
retrieve an requested histogram from the available postprocessors.



@section pplayout Post processorssing
Each post postprocessor has a list of pointers to histograms that it has
processed yet. This is there ensure that it will not evaluate the same event
over and over again. When it has already processed one event it will return the
resulting histogram associated with this event.\n
Some of the post processors do not have a separate result for each event,
ie. the summing up and averaging post processors. These contain a list of
histograms but each one points to the same resource.\
To make sure that in the cass::PostProcessorBackend::process() function one will
always use the right histograms there is an pointer that will always point to
the right histogram called cass::PostProcessorBackend::_result.

The following happens in each post processor when cass::Postprocessors::process()
will call the cass::PostProcessorsBackend::operator() member of each post
processor:
- search in cass::PostProcessorBackend::_histList whether there is a an entry
  that has the eventid as first part of the pair.
- when it is so then just return the second part of the pair.
- if it not so, check whether there is an condition and if so evalate it. If
  it turns out to be true call cass::PostProcessorBackend::process() for this
  event. And then return the pointer to the histogram that contains the result
  of the process.


@section addnew Adding new functionality to CASS

@section newpp How to add a new PostProcessor
A new PostProcessor needs to inherits from cass::PostprocessorBackend. The most
important function that need to be overwritten are
cass::PostProcessorBackend::loadSettings() and
cass::PostProcessorBackend::process().
In cass::PostProcessorBackend::loadSettings() you need to setup the
dependencies you are relying on if there are any, the general available parameters
and most imporantly the resulting histogram. With
cass::PostProcessorBackend::setupCondition() you set up that the PostProcessor
is conditionable. This needs to be called in each load settings overwritten member.
cass::PostProcessorBackend::setupGeneral() will setup all the parameters that are
available for PostProcessors. Optionally you can use the function member
cass::PostProcessorBackend::setupDependency() to set up the dependencies you
rely on. After initializing the cass::PostProcessorBackend::_result member you
can use the member function cass::PostProcessorBackend::createHistList() to
create the histogram list of the PostProcessor.

If your histogram relays on the a histogram of an dependcy, you might have to
overwrite cass::PostProcessorBackend::histogramsChanged() and assign a new
histogram with the new parameters to cass::PostProcessorBackend::_result. Calling
cass::PostProcessorBackend::createHistList() after that will make sure that the
old histogramlist is deleted properly before creating the new one. Make sure that
when you have altered your histogram to tell your dependands about this. You can
use cass::Postprocessors::find_dependant() to find all post processors that
depend on you. Then call the cass::PostProcessorBackend::histogramsChanged()
member of all the post processors that depend on you. Here is some example code
that does that for you
@code
//notify all pp that depend on us that our histograms have changed
PostProcessors::keyList_t dependands (_pp.find_dependant(_key));
PostProcessors::keyList_t::iterator it (dependands.begin());
for (; it != dependands.end(); ++it)
  _pp.getPostProcessor(*it).histogramsChanged(_result);
@endcode

If you modify the contents of your histogram by filling or doing other operations
on it make sure that you lock the histogram for write access using its
cass::HistogramBackend::lock. When you access histograms of your dependencies
you need to lock them for read access using theier cass::HistogramBackend::lock.
Access to the histograms of you dependencies should be done by calling the
dependencies cass::PostProcesssorBackend::operator() member for that event.
This will then return the resulting histogram for this event as described above.

When you are done coding your postprocessor you need to make it available to
the user. To do this you need to complete the following steps:
- in cass/postprocessing/postprocessor.h add the number and a short description
  in the desciption part.
- in cass/postprocessing/postprocessor.h add an entry with your id in the
  cass::PostProcessors::id_t enum.
- in cass/postprocessing/postprocessor.cpp add your id in the
  cass::PostProcessors::create() member to the switch statement. Just use the
  other entries as example.



@section newcon How to add a new Converter
converter class inerhit from cass::ConversionBackend.
in constructor needs to setup ids it works on
add it to converter::instance
modify description in cass::FormatConverter header.
*/
