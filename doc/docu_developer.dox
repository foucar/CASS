/**
@page developer Developer information

CASS has two basic parts the input and analyze. Where the input part gets the data
from either file or shared memory and the analyze part will analyze the data.
Both of them are threaded, where the input is always just one thread and the
analyze part consists of more threads. The linkage between the input threads
and the analysis thread is done by cass::RingBuffer. This is a buffer that
contains the amount of cass::CASSEvent elements that can be chosen by setting
cass::RingBufferSize. It allows to retrieve elements that should be filled with
new data and elements whose contents should be analyzed.


@section input Input part of CASS
Both inputs will do the following tasks after they retrieved the data from LCLS:
- get fillable (empty) cass::CASSEvent element from cass::RingBuffer
- convert LCLS data to cass::CASSEvent data and fill the later with the data
- put cass::CASSEvent back into cass::RingBuffer

To convert the data the cass::FormatConverter singleton is used. This will
iterate through the LCLS datagram and call the right cass::ConversionBackend
object that will convert the xtc data to cass::CASSEvent data. The user can
select what part of the data he wants to have converted by setting up which
converters he wants to use. Please refer to the documentation of
cass::FormatConverter and the converters for details.

@section offline_input Offline input of CASS
The input part that will read the data from file in offline mode is handled by
the class cass::FileInput. This just parses the input file containing the file
names to analyze, put them into string list and then goes through that list.
For each file it will retrieve an event and convert the data to cass::CASSEvent
object. The later was retrieved from the cass::RingBuffer and then later put back
into it.


@section online_input Online input of CASS
In the online mode the input part will read the data from the LCLS shared memory.
The corrosponding class is cass::SharedMemoryInput. It derives from the
Pds::XtcMonitorClient class provided by LCLS. This class will do all the
communication between the shared memory and CASS. Once it retrieved new data
(in LCLS terms this is called datagram) it will call the overwritten
cass::SharedMemoryInput::processDgram() member. Here the datagram will be
converted to a cass::CASSEvent which is retrieved from the cass::RingBuffer
before. After that it is put back into the cass::RingBuffer.



@section analysis Analysis part of CASS
The analysis part is done by multiple threads. One can set the number of analysis
threads by modifying the cass::NbrOfWorkers variable. Each
analysis thread is a cass::Worker object, which are handled by the cass::Workers
object. Each one of the cass::Worker objects will do the following until it is
told to quit:
- retrieve an analyzable (non empty) cass::CASSEvent element from cass::RingBuffer
- pre analyze the cass::CASSEvent element using the cass::Analyzer singleton
- post analyze the cass::CASSEvent element using the cass::PostProcessors
  singleton.
- put the event back to the ringbuffer to be refilled again.

The cass::Analyzer singleton will pass the cass event to all user selected pre
analyzers to pre process the data. The cass::PostProcessor will pass the event
to all user defined postprocessors to be postprocessed. For further details on
how to select what postprocessors should run please see section @ref inifilesetup.
A list of analyzers can be found in cass::Analyzer in which you can also find
links to specific documentation of each analyzer.

@section communication Communicating with CASS
CASS is using SOAP to communicate with the viewers. The class that handles these
communication is cass::SoapServer. It uses a cass::HistogramGetter object to
retrieve a requested histogram from the available postprocessors.



@section pplayout The post processors
Each post post processor has a list of pointers to histograms that it has
processed yet. This is to ensure that it will not evaluate the same event
over and over again. When it has already processed one event it will return the
resulting histogram associated with this event.\n
Some of the post processors do not have a separate result for each event,
i.e. the summing up and averaging post processors. These contain a list of
histograms but each one points to the same resource.\n
To make sure that in the cass::PostprocessorBackend::process() function one will
always use the right histograms there is an pointer that will always point to
the right histogram called cass::PostprocessorBackend::_result.

The following happens in each post processor when cass::PostProcessors::process()
will call the cass::PostprocessorBackend::operator()() member of each post
processor:
- search in cass::PostprocessorBackend::_histList whether there is a an entry
  that has the cass::CASSEvent::_id as first part of the pair.
- if so then just return the second part of the pair.
- if not, check whether there is an condition and in in this case evalate it. If
  the conditioin returns true call cass::PostprocessorBackend::process() for this
  event. And then return the pointer to the histogram that contains the result
  of the process.


@section addnew Adding new functionality to CASS

@section newpp How to add a new PostProcessor
A new PostProcessor needs to inherit from cass::PostprocessorBackend. The most
important function that need to be overwritten are
cass::PostprocessorBackend::loadSettings() and
cass::PostprocessorBackend::process().
In cass::PostprocessorBackend::loadSettings() you need to setup the
dependencies you are relying on if there are any, the general available parameters
and most importantly the resulting histogram. With
cass::PostprocessorBackend::setupCondition() you set up that the post processor
is conditionable. This needs to be called in each overwritten member cass::PostprocessorBackend::loadSettings ().
cass::PostprocessorBackend::setupGeneral() will setup all the parameters that are
available for post processors. Optionally you can use the function member
cass::PostprocessorBackend::setupDependency() to set up the dependencies you
rely on. After initializing the cass::PostprocessorBackend::_result member you
can use the member function cass::PostprocessorBackend::createHistList() to
create the histogram list of the post processor.

If your histogram relays on a histogram of an dependency, you might have to
overwrite cass::PostprocessorBackend::histogramsChanged() and assign a new
histogram with the new parameters to cass::PostprocessorBackend::_result. Calling
cass::PostprocessorBackend::createHistList() after that will make sure that the
old histogramlist is deleted properly before creating the new one. Make sure that
when you have altered your histogram to inform all dependance about the change. You
can use cass::PostProcessors::find_dependant() to find all post processors that
depend on you. Then call the cass::PostprocessorBackend::histogramsChanged()
member of all the post processors that depend on you. Here is some example code
that does that for you
@code
//notify all pp that depend on us that our histograms have changed
PostProcessors::keyList_t dependands (_pp.find_dependant(_key));
PostProcessors::keyList_t::iterator it (dependands.begin());
for (; it != dependands.end(); ++it)
  _pp.getPostProcessor(*it).histogramsChanged(_result);
@endcode

If you modify the contents of your histogram by filling or doing other operations
on it make sure that you lock the histogram for write access using its
cass::HistogramBackend::lock. When you access histograms of your dependencies
you need to lock them for read access using their cass::HistogramBackend::lock.
Access to the histograms of your dependencies should be done by calling the
dependencies cass::PostprocessorBackend::operator()() member for that event.
This will then return the resulting histogram for this event as described above.

When you are done coding your postprocessor you need to make it available to
the user. To do this you need to complete the following steps:
- in cass/postprocessing/postprocessor.h add the number and a short description
  in the description part.
- in cass/postprocessing/postprocessor.h add an entry with your id in the
  cass::PostProcessors::id_t enum.
- in cass/postprocessing/postprocessor.cpp add your id in the
  cass::PostProcessors::create() member to the switch statement. Just use the
  other entries as example.



@section newcon How to add a new Converter
Your converter has to inherit from cass::ConversionBackend and it should be a
singleton. This means that it should have a static member function called
instance that will return a cass::ConversionBackend::converterPtr_t object that
contains the singleton pointer.\n
In the constructor of the class you need to fill the
cass::ConversionBackend::_pdsTypeList with the type id's from the LCLS that you
want the converter to react on.\n
You need to overwrite cass::ConversionBackend::operator()() with the code that
extracts the desired data from the datagram and put it into the cass::CASSEvent.\n
Once you have set up your converter, you need to modify
cass::ConversionBackend::instance() and add an @c else-if-statment that returns
converter. Please document in cass/format_converter.h which string will return
your the singleton of your converter.
*/
