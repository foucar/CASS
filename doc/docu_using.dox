/**
@page using Using CASS


CASS is capable of running online (get the data from the LCLS datastream) and
offline (get the data from the xtc files written by the LCLS DAQ).
Depending on the settings during compiletime one can compile CASS for either
online or offline mode. Please see @ref compiling for details.\n
A complete list of all parameters can be found here @ref clpar. Some of the
parameters are only working with the online version some of them only with the
offline version of CASS. To quit CASS in either online or offline mode one can
use
@verbatim
crtl + \
@endverbatim
Killing the program with
@verbatim
crtl + c
@endverbatim
has various implications. Please refer to the following sections for details.



@section online Online
To run cass online you need shared memory access to the data
provided by LCLS. This access is only available on selected dedicated computers.
For the AMO-Hutch these are
@verbatim
daq-amo-mon01
.
.
daq-amo-mon04
@endverbatim
Please ask the LCLS DAQ people on which machine you will have access to the
online data stream.\n

When starting the online CASS program you need to determine where to find the
shared memory that has been preset by the DAQ people. (One can list the files in
@verbatim
/dev/shm
@endverbatim
to see which shared memory tags have been set up). The shared memory tag can
be passed to the program with the
@verbatim
-p <partition tag>
@endverbatim
parameter. If more than one person is running on the same machine trying to get
the data from the online stream it is possible to pass an id to each one with
the
@verbatim
-c <client id>
@endverbatim
parameter.
With the
@verbatim
-s <server port>
@endverbatim
parameter you tell the program on which port the cass histograms are provided to
the viewers. See @ref viewers for details on how to use this parameter in the
viewer.
The
@verbatim
-f <path/to/.inifile>
@endverbatim
parameter lets you choose which .ini file to use. Please see @ref inifilesetup
for details of the contents of the .ini file. If this parameter is not set CASS
will by default load CASS.ini that resides in the UserScope path. On Unix or Mac
OS X this is $HOME/.config or $HOME/Settings ie.
@verbatim
~/.config/CFEL-ASG/CASS.ini
@endverbatim
A typical program start command looks like this:
@verbatim
./cass -p 0_1_cass_AMO -c 0 -f "inifilename"
@endverbatim
For your convenience the most recent cass binary compiled by an expert is
located here
@verbatim
/reg/g/cass/bin/cass
@endverbatim
In this location you will also find some convenience startup scripts. The one
that loads cass with the parameters described in the example above is called
@verbatim
/reg/g/cass/bin/startCASS.sh </path/to/.inifile>
@endverbatim
where the .ini determines on which settings and parameter cass is run.

To end the program you should use
@verbatim
crtl + \
@endverbatim
Killing the program with
@verbatim
crtl + c
@endverbatim
will eat up shared_memory buffers. This means that you can
only do this a few times until all communication buffers are eaten up and you
don't get any data anymore. The only thing that allows CASS to get data from the
datastream again is to restart the DAQ.




@section offline Offline
The offline version of CASS will process the xtc file that were recorded by the
LCLS DAQ. Please put all files that you want to process into a txt file. Then
provide the name of the text file to CASS with the
@verbatim
-i <filename containing filenames of xtcfiles to process>
@endverbatim
parameter.\n
Usually CASS will not quit after it has finishes processing all the files. It
will keep all histograms in memory to be accessible via the viewers. If you would
like CASS to quit after it has processed all provided files you have to pass the
@verbatim
-q
@endverbatim
parameter to CASS at the program start.\n
Sometimes you don't want to have all the rate output, ie. when you run
the program in a batched way on a cluster. You can suppress the output with
@verbatim
-r
@endverbatim
Histograms can optionally be saved to either a root or a hdf5 file. The file format has
to be set in cass_myconfiq.pri and cass needs to be compiled whenever a chage is made to
this configuraion file.
Refer to @ref compiling for more details. The filename has to be specified with the
following parameter when executing cass:
@verbatim
-o <output filename>
@endverbatim
\n
If you want to quit the program before the file has been fully analyzed but
still want to dump everything that has been processed so far to
the file you can quit the program with
@verbatim
crtl + \
@endverbatim
Using
@verbatim
crtl + c
@endverbatim
will result in immediate stop of the program without the data being written to
file.





@section viewers The Viewers
There are two options to look at the histograms that are created and filled by CASS,
@ref jocassview and @ref lucassview. Both viewers need to be told on
which server CASS is running and on which port it will listen for requests.


@section jocassview Jocassview
This viewer is based on QWT. A library for scientific widgets that are based on
QT. To start this viewer on the SLAC computers the QWT library has to be added to the
LD_LIBRARY_PATH variable. i. e.
@verbatim
export LD_LIBRARY_PATH=/reg/g/cass/lib
./jocassview
@endverbatim
At LCLS, one can also use the convenience startup script that will set the
commands above automaticaly. It is located in the cass directory. Here is how
to start it:
@verbatim
/reg/g/cass/bin/startJocassview.sh
@endverbatim


@section lucassview Lucassview
This viewer is based on ROOT which was developed by CERN and is a C++
library for all kinds of things. Please visit http://root.cern.ch for details.
To start this viewer on the SLAC computers one has to set PATH and
LD_LIBRARY_PATH to point to the binary and the library path
of the root installation. ie
@verbatim
export ROOTSYS=/reg/common/package/root/5.24.00-x86_64-nodebug
export PATH=$ROOTSYS/bin:$PATH
export LD_LIBRARY_PATH=$ROOTSYS/lib:$LD_LIBRARY_PATH
./lucassview
@endverbatim
At LCLS, there is also a convenience script available that will set
the environmental variables and start the lucassviewer
@verbatim
/reg/g/cass/bin/startLucassview.sh
@endverbatim
In order to run properly one has to provide a startup script to lucassview'er
which is called lucassStartup.C. Apart from the declaration of the appropriate server and
port, there are several options such as an automatic update.
All options in the script can also
be typed in the root console manually. A template is located here:
@verbatim
/reg/g/cass/macros/lucassStartup.C
@endverbatim
or in the lucassview folder of the repository you have downloaded.\n
In order to increase the usability of root there are a collection of macros
available, which need to be loaded to root. This collection of macros can be
found here:
@verbatim
/reg/g/cass/macros/MoritzLutzAchimTill.C
@endverbatim



@section inifilesetup How to set up the .ini file
CASS consists of a lot of "lego" pieces that one can
put together to process the data as you want it. These "lego"
pieces are called "PostProcessors". For better understanding of this concept,
here is a short overview of the
program flow:\n
for each event
- receive an event containing all data from either the xtc file (offline) or the
  shared memory.
- pick out the information we are interested in (Converters)
- preprocess parts of the data (PreAnalyzer)
- postprocess the data using the PostProcessors

So the ini file exist of basically three parts:

The Converter part tells CASS what kind of data you are actually interested in.
To see what options are available please refer to @ref converter.

The PreAnalyzer part will preprocess only the pnCCD and the ccd data. Please
refer to @ref preanalyzer for details how to tell which pre analyzers should be
used by CASS. The parameters you can set for the different pre analyzers can be
found in the description of cass::pnCCD::DetectorParameter and cass::pnCCD::Parameter
for the pnCCD pre analysis. For the commercial ccd pre analysis the paramters
can be found in the description of cass::CCD::Parameter.\n

The PostProcessor part is the most advanced part. #ref pplist gives an overview
of all available postprocessors. The parenthesis refers to the
postprocessor to look up in the parameter list @ref CASSParameters to find out which
parameters it takes. In this reference you will also find all available
parameters that one can give in the .ini file. There are some examples given in
@ref examples as a starting point for your .ini file.

@section acqirisdetectors The special Acqiris Detector Parameters
If you want to use the PostProcessors that deal with the AcqirisDetectors you
need to set up the AcqirisDetectors first. Basically there are two types of
Acqiris Detectors:
- Time of Flight detectors (ToF)
- Delayline detectors (DLD)

where the Delayline detectors are Time of Flight detectors with additional spatial
information. So
everything that a Time of Flight detector can do, also a Delayline detector will
do, but more. Basically the concept behind these detectors is that a ToF detector
has a cass::ACQIRIS::SignalProducer which is called MCP. The SignalProducer
contains a SingalExtractor object that knows where to find the signals in the
data and how to extract them from there. The parameter @c SignalExtractionMethod
lets you choose what kind of SignalExtractor should be used to extract the
signals from the data. Please refer to the specific SignalExtrator for its available
parameters.

Next to an MCP SignalProducer the delay line detector (DLD) has also
cass::ACQIRIS::AnodeLayer which
contain wireends which themselves are again cass::ACQIRIS::SignalProducer. So
one can set up how to extract the produced signals from the wireends as
described for the MCP SignalProducer.\n
To be able to convert or resort the Signals produced by the MCP
and the wireends of a DLD to actual hits on the detector the DLD also contains
a DetectorAnalyzer object. There are several ways to sort the signals into
detectorhits. You can choose which one of these methods you want to use with the
@c AnalysisMethod parameter. Please refer to the description of the specific
DetectorAnalyzer to see what parameters are available.

Once you have set up the DLD to identify hits, these hits can be refered to certain particle
There are several ways of identifying which hit
belongs to which particle. You can choose which one to use with the @c ConditionType
parameter of the particle to define which method to use. For the other parameters
available for a particle please refer to the documentation of
cass::ACQIRIS::Particle. In order to calculate the momenta and energy of the
particle each particle contains a cass cass::ACQIRIS::Spectrometer object. You
need to set up this object for each particle individually. Based on the parameters
you provide the particle will decide which method it will use to calculate the
momentum. In this the raw values of the detectorhit are taken and corrected
using a cass::ACQIRIS::HitCorrector object. Please refer to the documentation
of cass::ACQIRIS::HitCorrector to see which parameters are available.



@section getting_help Getting Help
If you need further assistance please subscribe yourself to the cass-mailinglist.\n
https://www.asg.mpg.de/mailman/listinfo/cass\n
Where people should share their experience and users and developers are helping
other users to solve their problems.
*/

