;;
;; this ini file tries to identify when there was a particle interacting with
;; the FEL.
;; There are several ways of identifying, either in the ToF or in on the opal
;; vmi phosphor screen.
;; When trying to identify a hit using the camera images it calculates the
;; Integral over a user selected part of the camera and checks whether this
;; integral deviates from the median of this integral.
;; For the ToF one just checks whehter the integral in specific time
;; window goes below a certain threshold (below, because in this case
;; the signals form the ToF are negative.
;;


; ---------------------the postprocessors--------------------------

;----------------the raw images / tof traces-----------------------

; opal camera image
[PostProcessor]
Opal/ID=105
Opal/Detector = Opal
Opal/Write = false

; thresholded opal camera image
[PostProcessor]
ThresholdOpal/ID = 148
ThresholdOpal/Detector = Opal
ThresholdOpal/XNbrBins = 1024
ThresholdOpal/XLow = 0
ThresholdOpal/XUp = 1023
ThresholdOpal/YNbrBins = 1024
ThresholdOpal/YLow = 0
ThresholdOpal/YUp = 1023
ThresholdOpal/PixelvalueAsWeight = true
ThresholdOpal/SpectralLowerLimit = 0
ThresholdOpal/SpectralUpperLimit = 1e6
ThresholdOpal/Write = false


; raw ToF trace and an average of it
[PostProcessor]
ToF/ID = 110
ToF/Write = false
ToF/InstrumentId = 3
ToF/ChannelNbr = 0
ToF/Write = false
ToFAverage/ID = 61
ToFAverage/NbrOfAverages = 100
ToFAverage/HistName = ToF
ToFAverage/Write = false

;accumulated ToF using CFD
[;PostProcessor]
AccumulatedToF/ID = 151
AccumulatedToF/Detector = ToF
AccumulatedToF/XNbrBins = 20000
AccumulatedToF/XLow = 0
AccumulatedToF/XUp = 20000
AccumulatedToF/Hide = true
AccumulatedToF/Write = false
AccumulatedToFSum/ID = 62
AccumulatedToFSum/HistName = AccumulatedToF
AccumulatedToFSum/Write = false



; The rear detector image
[PostProcessor]
RearPnCCDNotRotated/ID = 105
RearPnCCDNotRotated/Detector = RearPnCCD
RearPnCCDNotRotated/Write = false

; offset map rear detector
[PostProcessor]
RearPnCCDOffsetMapNotRotated/ID = 107
RearPnCCDOffsetMapNotRotated/Detector = RearPnCCD
RearPnCCDOffsetMapNotRotated/MapType = offset
RearPnCCDOffsetMapNotRotated/Write = false

; noise map rear detector
[PostProcessor]
RearPnCCDNoiseMapNotRotated/ID = 107
RearPnCCDNoiseMapNotRotated/Detector = RearPnCCD
RearPnCCDNoiseMapNotRotated/MapType = noise
RearPnCCDNoiseMapNotRotated/Write = false

; mask rear detector
[PostProcessor]
RearPnCCDGainNotRotated/ID = 107
RearPnCCDGainNotRotated/Detector = RearPnCCD
RearPnCCDGainNotRotated/MapType = correction
RearPnCCDGainNotRotated/Write = false



; The front detector image
[PostProcessor]
FrontPnCCDNotRotated/ID = 105
FrontPnCCDNotRotated/Detector = FrontPnCCD
FrontPnCCDNotRotated/Write = false

; offset map Front detector
[PostProcessor]
FrontPnCCDOffsetMapNotRotated/ID = 107
FrontPnCCDOffsetMapNotRotated/Detector = FrontPnCCD
FrontPnCCDOffsetMapNotRotated/MapType = offset
FrontPnCCDOffsetMapNotRotated/Write = false

; noise map Front detector
[PostProcessor]
FrontPnCCDNoiseMapNotRotated/ID = 107
FrontPnCCDNoiseMapNotRotated/Detector = FrontPnCCD
FrontPnCCDNoiseMapNotRotated/MapType = noise
FrontPnCCDNoiseMapNotRotated/Write = false

; mask Front detector
[PostProcessor]
FrontPnCCDGainNotRotated/ID = 107
FrontPnCCDGainNotRotated/Detector = FrontPnCCD
FrontPnCCDGainNotRotated/MapType = correction
FrontPnCCDGainNotRotated/Write = false




;------------- definitions of when a hit is found------------------


; take an integral of a certain area of the thresholded opal camera
; take the median of this integral and substract median from the
; integral. A hit is found when the substracted integral exeeds a
; certain limit.
[PostProcessor]
PhosphorProject/ID = 50
PhosphorProject/HistName = ThresholdOpal
PhosphorProject/LowerBound = 450                         ;! y range form where
PhosphorProject/UpperBound = 580                         ;! y range to where
PhosphorProject/Axis = 0                                 ; project to x axis
PhosphorProject/Hide = true
PhosphorProject/Write = false
PhosphorAreaIntegral/ID = 51
PhosphorAreaIntegral/HistName = PhosphorProject
PhosphorAreaIntegral/LowerBound = 490                     ; x range from where
PhosphorAreaIntegral/UpperBound = 700                     ; x range to where
PhosphorAreaIntegral/Hide = true
PhosphorAreaIntegral/Write = false
PhosphorAreaIntegralMedian/ID = 301
PhosphorAreaIntegralMedian/MedianSize = 10                ; the median size
PhosphorAreaIntegralMedian/HistName = PhosphorAreaIntegral
PhosphorAreaIntegralMedian/Hide = true
PhosphorAreaIntegralMedian/Write = false
PhosphorAreaIntegralDeviation/ID = 20
PhosphorAreaIntegralDeviation/HistOne = PhosphorAreaIntegral
PhosphorAreaIntegralDeviation/HistTwo = PhosphorAreaIntegralMedian
PhosphorAreaIntegralDeviation/Hide = true
PhosphorAreaIntegralDeviation/Write = false
PhosphorAreaIntegralDeviationHistory/ID = 64
PhosphorAreaIntegralDeviationHistory/HistName = PhosphorAreaIntegralDeviation
PhosphorAreaIntegralDeviationHistory/Size = 5000         ; how big the history is
PhosphorAreaIntegralDeviationHistory/Write = false
PhosphorHitfinder/ID = 9
PhosphorHitfinder/HistName = PhosphorAreaIntegralDeviation
PhosphorHitfinder/UpperLimit = 1e20                           ; upper limit needs to be very high
PhosphorHitfinder/LowerLimit = 1e6                            ;! limit that needs to be exceeded
PhosphorHitfinder/Hide = true
PhosphorHitfinder/Write = false


; an integral over a certain region of the rear detector
; done by projecting a given range on the x-axis and then taking
; the integral of the projection within a certain range of the axis
; substract the median of the integral from the integral and use
; the substracted to find the hit
[PostProcessor]
RearPnCCDProject/ID = 50
RearPnCCDProject/HistName = RearPnCCDNotRotated
RearPnCCDProject/LowerBound = 300                            ;! y range form where
RearPnCCDProject/UpperBound = 750                            ;! y range to where
RearPnCCDProject/Axis = 0                                    ; project to x axis
RearPnCCDProject/Hide = true
RearPnCCDProject/Write = false
RearPnCCDAreaIntegral/ID = 51
RearPnCCDAreaIntegral/HistName = RearPnCCDProject
RearPnCCDAreaIntegral/LowerBound = 200                       ; x range from where
RearPnCCDAreaIntegral/UpperBound = 480                       ; x range to where
RearPnCCDAreaIntegral/Hide = true
RearPnCCDAreaIntegral/Write = false
RearPnCCDIntegralMedian/ID = 301
RearPnCCDIntegralMedian/MedianSize = 10
RearPnCCDIntegralMedian/HistName = RearPnCCDAreaIntegral
RearPnCCDIntegralMedian/Hide = true
RearPnCCDIntegralMedian/Write = false
RearPnCCDIntegralDeviation/ID = 20
RearPnCCDIntegralDeviation/HistOne = RearPnCCDAreaIntegral
RearPnCCDIntegralDeviation/HistTwo = RearPnCCDIntegralMedian
RearPnCCDIntegralDeviation/Hide = true
RearPnCCDIntegralDeviation/Write = false
RearPnCCDIntegralDeviationHistory/ID = 64
RearPnCCDIntegralDeviationHistory/HistName = RearPnCCDIntegralDeviation
RearPnCCDIntegralDeviationHistory/Size = 5000
RearPnCCDIntegralDeviationHistory/Write = false
RearPnCCDHitfinder/ID = 9
RearPnCCDHitfinder/HistName = RearPnCCDIntegralDeviation
RearPnCCDHitfinder/UpperLimit = 1e20
RearPnCCDHitfinder/LowerLimit = 200000                   ;! limit that needs to be exceeded
RearPnCCDHitfinder/Hide = true
RearPnCCDHitfinder/Write = false



; take the integral of certain areas in the ToF trace, when they
; are below a certain threshold

; fluorescence peak
[;PostProcessor]
FluorescenceIntegral/ID = 51
FluorescenceIntegral/HistName = ToF
FluorescenceIntegral/LowerBound = 1500e-9            ; the lower limit of the range
FluorescenceIntegral/UpperBound = 1600e-9            ; the upper limit of the range
FluorescenceIntegral/Hide = true
FluorescenceIntegral/Write = false
FluorescenceIntegralHistory/ID = 64
FluorescenceIntegralHistory/Size = 5000
FluorescenceIntegralHistory/HistName = FluorescenceIntegral
FluorescenceIntegralHistory/Write = false
FluorescenceHitfinder/ID = 9
FluorescenceHitfinder/HistName = FluorescenceIntegral
FluorescenceHitfinder/UpperLimit = -1                ; the upper limit to be undercut
FluorescenceHitfinder/LowerLimit = -1e20
FluorescenceHitfinder/Hide = true
FluorescenceHitfinder/Write = false

;for He3 1+ peak
[;PostProcessor]
HeIntegral/ID = 51
HeIntegral/HistName = ToF
HeIntegral/LowerBound = 6900e-9                      ; the lower limit of the range
HeIntegral/UpperBound = 7150e-9                      ; the upper limit of the range
HeIntegral/Hide = true
HeIntegral/Write = false
HeIntegralHistory/ID = 64
HeIntegralHistory/Size = 5000
HeIntegralHistory/HistName = HeIntegral
HeIntegralHistory/Write = false
HeHitfinder/ID = 9
HeHitfinder/HistName = HeIntegral
HeHitfinder/UpperLimit = 0.5                        ; the upper limit to be undercut
HeHitfinder/LowerLimit = -1e20
HeHitfinder/Hide = true
HeHitfinder/Write = false

; the xenon peak
[;PostProcessor]
XeIntegral/ID = 51
XeIntegral/HistName = ToF
XeIntegral/LowerBound = 8200e-9                      ; the lower limit of the range
XeIntegral/UpperBound = 11000e-9                     ; the upper limit of the range
XeIntegral/Hide = true
XeIntegral/Write = false
XeIntegralHistory/ID = 64
XeIntegralHistory/Size = 1000
XeIntegralHistory/HistName = XeIntegral
XeIntegralHistory/Write = false
XeHitfinder/ID = 9
XeHitfinder/HistName = XeIntegral
XeHitfinder/UpperLimit = 32                         ; the upper limit to be undercut
XeHitfinder/LowerLimit = -1e20
XeHitfinder/Hide = true
XeHitfinder/Write = false





; define which of the hitfinders defined above will be used as hit
; identification for the later PostProcessors by ANDing this with
; true. Then one can use the IsHit PostProcessor later on, by only
; chaning here which condition to use.
[PostProcessor]
IsHit/ID = 5
IsHit/HistOne = DefaultTrueHist
;IsHit/HistTwo = PhosphorHitfinder
IsHit/HistTwo = RearPnCCDHitfinder
IsHit/Hide = true
IsHit/Write = false

; define its a non hit when its not a hit
[PostProcessor]
IsNotHit/ID = 4
IsNotHit/HistName = IsHit
IsNotHit/Hide = true
IsNotHit/Write = false

; display the hit rate: average of the isHit over so many shots
[;PostProcessor]
HitRate/ID = 61
HitRate/HistName = IsHit
HitRate/NbrOfAverages = 1000        ;! how many shots should be averaged
HitRate/Hide = true
HitRate/Write = false
HitRateHistory/ID = 64
HitRateHistory/HistName = HitRate
HitRateHistory/Size = 5000
HitRateHistory/Write = false



;--------------- things done when there is a hit-------------------

; the raw opal camera image
[PostProcessor]
OpalIsHit/ID=105
OpalIsHit/Detector = Opal
OpalIsHit/ConditionName = IsHit
OpalIsHit/Write = true

; the thresholded opal camera image
[PostProcessor]
ThresholdOpalIsHit/ID = 148
ThresholdOpalIsHit/Detector = Opal
ThresholdOpalIsHit/XNbrBins = 1024
ThresholdOpalIsHit/XLow = 0
ThresholdOpalIsHit/XUp = 1023
ThresholdOpalIsHit/YNbrBins = 1024
ThresholdOpalIsHit/YLow = 0
ThresholdOpalIsHit/YUp = 1023
ThresholdOpalIsHit/PixelvalueAsWeight = true
ThresholdOpalIsHit/SpectralLowerLimit = 0      ;arbitray threshold (set in detector definition)
ThresholdOpalIsHit/SpectralUpperLimit = 1e6
ThresholdOpalIsHit/ConditionName = IsHit
ThresholdOpalIsHit/Write = true


; the tof trace
[PostProcessor]
ToFIsHit/ID = 110
ToFIsHit/InstrumentId = 3
ToFIsHit/ChannelNbr = 0
ToFIsHit/ConditionName = IsHit
ToFIsHit/Write = true


; the rear pnccd images when there is a hit
[PostProcessor]
RearPnCCDIsHit/ID = 55
RearPnCCDIsHit/HistName = RearPnCCDNotRotated
RearPnCCDIsHit/Operation = 90DegCCW
RearPnCCDIsHit/ConditionName = IsHit
RearPnCCDIsHit/Write = true

; the front pnccd images when there is a hit
[PostProcessor]
FrontPnCCDIsHit/ID = 55
FrontPnCCDIsHit/HistName = FrontPnCCDNotRotated
FrontPnCCDIsHit/Operation = 90DegCCW
FrontPnCCDIsHit/ConditionName = IsHit
FrontPnCCDIsHit/Write = true



; Average rear pnccd image when its not a hit and substract it
; from the current image, to clear the image from background
[PostProcessor]
RearPnCCDNotRotatedIsNotHitAve/ID = 61
RearPnCCDNotRotatedIsNotHitAve/HistName = RearPnCCDNotRotated
RearPnCCDNotRotatedIsNotHitAve/NbrOfAverages = 200
RearPnCCDNotRotatedIsNotHitAve/ConditionName = IsNotHit
RearPnCCDNotRotatedIsNotHitAve/Write = false
RearPnCCDIsHitClearedNotRotated/ID = 20
RearPnCCDIsHitClearedNotRotated/HistOne = RearPnCCDNotRotated
RearPnCCDIsHitClearedNotRotated/HistTwo = RearPnCCDNotRotatedIsNotHitAve
RearPnCCDIsHitClearedNotRotated/ConditionName = IsHit
RearPnCCDIsHitClearedNotRotated/Hide = true
RearPnCCDIsHitClearedNotRotated/Write = false
RearPnCCDIsHitCleared/ID = 55
RearPnCCDIsHitCleared/HistName = RearPnCCDIsHitClearedNotRotated
RearPnCCDIsHitCleared/Operation = 90DegCCW
RearPnCCDIsHitCleared/ConditionName = IsHit
RearPnCCDIsHitCleared/Write = true



; convert the rear pnCCD image from kartesian coordinates to
; polar coordinates. Project a certain region of R and subset the
; phi range to only take the lower half of the detector. Calculate
; the mean of the resulting histogram and normalize the histogram
; by this mean. Then calculate the standart deviation of the
; normalized histogram
[PostProcessor]
RearPnCCDIsHitPolar/ID = 202
RearPnCCDIsHitPolar/HistName = RearPnCCDIsHitCleared
RearPnCCDIsHitPolar/ImageXCenter = 512
RearPnCCDIsHitPolar/ImageYCenter = 520
RearPnCCDIsHitPolar/NbrAngularPoints = 180
RearPnCCDIsHitPolar/NbrRadialPoints = 500
RearPnCCDIsHitPolar/ConditionName = IsHit
RearPnCCDIsHitPolar/Write = false
RearPnCCDPolarProject/ID = 50
RearPnCCDPolarProject/HistName = RearPnCCDIsHitPolar
RearPnCCDPolarProject/LowerBound = 45                  ;! y range form where
RearPnCCDPolarProject/UpperBound = 80                  ;! y range to where
RearPnCCDPolarProject/Axis = 0                         ; project to x axis
RearPnCCDPolarProject/ConditionName = IsHit
RearPnCCDPolarProject/Write = false
RearPnCCDPolarLowerHalf/ID = 70
RearPnCCDPolarLowerHalf/HistName = RearPnCCDPolarProject
RearPnCCDPolarLowerHalf/XLow = 110
RearPnCCDPolarLowerHalf/XUp = 250
RearPnCCDPolarLowerHalf/ConditionName = IsHit
RearPnCCDPolarLowerHalf/Write = false
RearPnCCDPolarLowerHalfMean/ID = 82
RearPnCCDPolarLowerHalfMean/HistName = RearPnCCDPolarLowerHalf
RearPnCCDPolarLowerHalfMean/ConditionName = IsHit
RearPnCCDPolarLowerHalfMean/Write = false
RearPnCCDPolarLowerHalfNormalized/ID = 33
RearPnCCDPolarLowerHalfNormalized/HistOne = RearPnCCDPolarLowerHalf
RearPnCCDPolarLowerHalfNormalized/HistZeroD = RearPnCCDPolarLowerHalfMean
RearPnCCDPolarLowerHalfNormalized/ConditionName = IsHit
RearPnCCDPolarLowerHalfNormalized/Write = false
RearPnCCDPolarLowerHalfStdev/ID = 83
RearPnCCDPolarLowerHalfStdev/HistName = RearPnCCDPolarLowerHalfNormalized
RearPnCCDPolarLowerHalfStdev/ConditionName = IsHit
RearPnCCDPolarLowerHalfNormalized/Write = false




;------------------------------- output----------------------------

; output the selected postprocessors to hdf5 file only when we there
; was a hit. Filename should be given with the -o commandline parameter.
[;PostProcessor]
dump/ID = 1001
dump/Write2dAsMatrix = true
dump/WriteBeamlineData = true
dump/WriteEpicsData = true
dump/WriteEvrCodes = true
dump/Compress = true
dump/ConditionName = IsHit




;-------------------program control and setup----------------------

;disable the pre analyzers as their functionality is ported to the new framework
[PreAnalyzer]
useCommercialCCDAnalyzer = false
usepnCCDAnalyzer = false

; only extract pnCCD, other camera data and machine data from the stream
[Converter]
Used = pixeldetector,Machine,Acqiris

; what output level should be written into the log file
[Log]
LoggingLevel = "INFO"


;------------------definition of the opal cam----------------------
[PixelDetectors]
Opal/Detector = 2                                           ; id of the camera
Opal/FrameProcessorType = "none"                            ; don't apply any corrections
Opal/PixelFinderType = "range"                              ; find all pixels that are in a user defined range and add them to the pixel list
Opal/InRangeFinder/LowerThreshold = 12                      ; lower bound of the range
Opal/InRangeFinder/UpperThreshold = 1e6                     ; upper bound of the range


;------------------definition of the rear detector-----------------
[PixelDetectors]
RearPnCCD/Detector = 1                                                                   ; detector id

; set up the hll like processing (removes offset and applies the mask)
RearPnCCD/FrameProcessorType = "hll"
RearPnCCD/HLLProcessing/CommonModeCalculationType = "none"                               ; no commonmode correction
; set up the correction maps used with the hll type processing
RearPnCCD/CorrectionMaps/NoisyPixelThreshold = 15                                        ; add all pixels to the mask, whose noise exceeds this value
RearPnCCD/CorrectionMaps/MapCreatorType = "onlinecommonmode"                             ; fast calculation with fixed amount of events taken to create the correction maps. Optionally remove the the common mode before calculting the offset and noise
RearPnCCD/CorrectionMaps/FixedOnlineCreatorCommonMode/NbrFrames = 200                    ; the number of frames included for the darkcalibration
RearPnCCD/CorrectionMaps/FixedOnlineCreatorCommonMode/WriteMaps = true                   ; write the calculated maps to file.
RearPnCCD/CorrectionMaps/FixedOnlineCreatorCommonMode/Multiplier = 4                     ; if the individual pixel is this times higher than the average noise it will not be included in the calculation of the map
RearPnCCD/CorrectionMaps/FixedOnlineCreatorCommonMode/CommonModeCalculationType = "none" ; no common mode correction when creation offset / noise maps
RearPnCCD/CorrectionMaps/InputOffsetNoiseFiletype = "hll"                                ; The calibration file is in the hll file format.
RearPnCCD/CorrectionMaps/InputOffsetNoiseFilename = "darkcal_1.lnk"                      ; default name. The link should point to the latest darkcalibration file.


; the mask elements
RearPnCCD/CorrectionMaps/Mask/size = 0                     ; the number of mask elements that will result in the final mask
; example mask types
RearPnCCD/CorrectionMaps/Mask/1/MaskElementType = "circle"
RearPnCCD/CorrectionMaps/Mask/1/CenterX = 500
RearPnCCD/CorrectionMaps/Mask/1/CenterY = 500
RearPnCCD/CorrectionMaps/Mask/1/Radius = 100
RearPnCCD/CorrectionMaps/Mask/2/MaskElementType = "square"
RearPnCCD/CorrectionMaps/Mask/2/LowerLeftX = 10
RearPnCCD/CorrectionMaps/Mask/2/LowerLeftY = 10
RearPnCCD/CorrectionMaps/Mask/2/UpperRightX = 90
RearPnCCD/CorrectionMaps/Mask/2/UpperRightY = 90
RearPnCCD/CorrectionMaps/Mask/3/MaskElementType = "ellipse"
RearPnCCD/CorrectionMaps/Mask/3/CenterX = 500
RearPnCCD/CorrectionMaps/Mask/3/CenterY = 500
RearPnCCD/CorrectionMaps/Mask/3/SemiAxisX = 50
RearPnCCD/CorrectionMaps/Mask/3/SemiAxisY = 10
RearPnCCD/CorrectionMaps/Mask/4/MaskElementType = "triangle"
RearPnCCD/CorrectionMaps/Mask/4/PointA_X = 10
RearPnCCD/CorrectionMaps/Mask/4/PointA_Y = 10
RearPnCCD/CorrectionMaps/Mask/4/PointB_X = 20
RearPnCCD/CorrectionMaps/Mask/4/PointB_Y = 10
RearPnCCD/CorrectionMaps/Mask/4/PointC_X = 10
RearPnCCD/CorrectionMaps/Mask/4/PointC_Y = 20



;------------------definition of the Front detector----------------
[PixelDetectors]
FrontPnCCD/Detector = 0                                                                   ; detector id

; set up the hll like processing (removes offset and applies the mask)
FrontPnCCD/FrameProcessorType = "hll"
FrontPnCCD/HLLProcessing/CommonModeCalculationType = "none"                               ; no commonmode correction
; set up the correction maps used with the hll type processing
FrontPnCCD/CorrectionMaps/NoisyPixelThreshold = 10                                        ; add all pixels to the mask, whose noise exceeds this value
FrontPnCCD/CorrectionMaps/MapCreatorType = "onlinecommonmode"                             ; fast calculation with fixed amount of events taken to create the correction maps. Optionally remove the the common mode before calculting the offset and noise
FrontPnCCD/CorrectionMaps/FixedOnlineCreatorCommonMode/NbrFrames = 200                    ; the number of frames included for the darkcalibration
FrontPnCCD/CorrectionMaps/FixedOnlineCreatorCommonMode/WriteMaps = true                   ; write the calculated maps to file.
FrontPnCCD/CorrectionMaps/FixedOnlineCreatorCommonMode/Multiplier = 4                     ; if the individual pixel is this times higher than the average noise it will not be included in the calculation of the map
FrontPnCCD/CorrectionMaps/FixedOnlineCreatorCommonMode/CommonModeCalculationType = "none" ; no common mode correction when creation offset / noise maps
FrontPnCCD/CorrectionMaps/InputOffsetNoiseFiletype = "hll"                                ; The calibration file is in the hll file format.
FrontPnCCD/CorrectionMaps/InputOffsetNoiseFilename = "darkcal_0.lnk"                      ; default name. The link should point to the latest darkcalibration file.

; the mask elements
FrontPnCCD/CorrectionMaps/Mask/size = 0                                                   ; the number of mask elements that will result in the final mask
FrontPnCCD/CorrectionMaps/Mask/1/MaskElementType = "square"
FrontPnCCD/CorrectionMaps/Mask/1/LowerLeftX = 490
FrontPnCCD/CorrectionMaps/Mask/1/LowerLeftY = 500
FrontPnCCD/CorrectionMaps/Mask/1/UpperRightX = 700
FrontPnCCD/CorrectionMaps/Mask/1/UpperRightY = 1023


; example mask types
;FrontPnCCD/CorrectionMaps/Mask/1/MaskElementType = "circle"
;FrontPnCCD/CorrectionMaps/Mask/1/CenterX = 500
;FrontPnCCD/CorrectionMaps/Mask/1/CenterY = 500
;FrontPnCCD/CorrectionMaps/Mask/1/Radius = 100
;FrontPnCCD/CorrectionMaps/Mask/2/MaskElementType = "square"
;FrontPnCCD/CorrectionMaps/Mask/2/LowerLeftX = 10
;FrontPnCCD/CorrectionMaps/Mask/2/LowerLeftY = 10
;FrontPnCCD/CorrectionMaps/Mask/2/UpperRightX = 90
;FrontPnCCD/CorrectionMaps/Mask/2/UpperRightY = 90
;FrontPnCCD/CorrectionMaps/Mask/3/MaskElementType = "ellipse"
;FrontPnCCD/CorrectionMaps/Mask/3/CenterX = 500
;FrontPnCCD/CorrectionMaps/Mask/3/CenterY = 500
;FrontPnCCD/CorrectionMaps/Mask/3/SemiAxisX = 50
;FrontPnCCD/CorrectionMaps/Mask/3/SemiAxisY = 10
;FrontPnCCD/CorrectionMaps/Mask/4/MaskElementType = "triangle"
;FrontPnCCD/CorrectionMaps/Mask/4/PointA_X = 10
;FrontPnCCD/CorrectionMaps/Mask/4/PointA_Y = 10
;FrontPnCCD/CorrectionMaps/Mask/4/PointB_X = 20
;FrontPnCCD/CorrectionMaps/Mask/4/PointB_Y = 10
;FrontPnCCD/CorrectionMaps/Mask/4/PointC_X = 10
;FrontPnCCD/CorrectionMaps/Mask/4/PointC_Y = 20





;----------------------------ToF-----------------------------------
[AcqirisDetectors]
ToF/DetectorType = 1       ; 1: Time of Flight Detector

; Constant fraction for MCP
ToF/MCP/SignalExtractionMethod = 3                 ; 16bit CFD
ToF/MCP/ConstantFraction/AcqirisInstrument = 3     ; Acqiris plate
ToF/MCP/ConstantFraction/ChannelNumber = 1         ;channel on Acqiris
ToF/MCP/ConstantFraction/Timeranges/size = 1       ;only one time range
ToF/MCP/ConstantFraction/Timeranges/1/LowerLimit = 0      ;min TOF limit in nanoseconds
ToF/MCP/ConstantFraction/Timeranges/1/UpperLimit = 40000  ;max TOF limit in nanoseconds
ToF/MCP/ConstantFraction/Polarity = 2                     ;negative
ToF/MCP/ConstantFraction/Threshold= 80e-3                 ;threshold in V (consider that the baseline may drift after strong peaks and then peaks may fall below the former threshold)
ToF/MCP/ConstantFraction/Delay = 3                        ;delay in nanoseconds (between 10-90% of the pulse FWHM)
ToF/MCP/ConstantFraction/Fraction = 0.8                   ;fraction, when to trigger
ToF/MCP/ConstantFraction/Walk = 0                         ;
