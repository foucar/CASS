;;
;; this ini file tries to identify when there was a particle interacting with
;; the FEL.
;; It calculates the Integral over a user selected part of the pnCCD and
;; checks whether this integral deviates from the median of this integral.
;;


; ---------------------the postprocessors--------------------------

; The rear detector image
[PostProcessor]
RearPnCCD_/ID = 105
RearPnCCD_/Detector = RearPnCCD
RearPnCCD_/Hide = true
RearPnCCD/ID = 55
RearPnCCD/HistName = RearPnCCD_
RearPnCCD/Operation = 90DegCCW

; The front detector image
[PostProcessor]
FrontPnCCD_/ID = 105
FrontPnCCD_/Detector = FrontPnCCD
FrontPnCCD_/Hide = true
FrontPnCCD_/ID = 55
FrontPnCCD/HistName = FrontPnCCD_
FrontPnCCD/Operation = 90DegCCW


; an integral over a certain region of the rear detector
; done by projecting a given range on the x-axis and then taking
; the integral of the projection within a certain range of the axis
[PostProcessor]
RearPnCCDProject/ID = 50
RearPnCCDProject/HistName = RearPnCCD
RearPnCCDProject/LowerBound = 400                            ;! range form where
RearPnCCDProject/UpperBound = 500                            ;! range to where
RearPnCCDProject/Axis = 1                                    ; project to y axis
RearPnCCDProject/Hide = true
RearPnCCDAreaIntegral/ID = 51
RearPnCCDAreaIntegral/HistName = RearPnCCDProject
RearPnCCDAreaIntegral/LowerBound = 400
RearPnCCDAreaIntegral/UpperBound = 500

; median of integral and its evolution (history)
[PostProcessor]
RearPnCCDIntegralMedian/ID = 301
RearPnCCDIntegralMedian/medianSize = 100
RearPnCCDIntegralMedian/HistName = RearPnCCDAreaIntegral
RearPnCCDIntegralMedian/Hide = true
RearPnCCDIntegralHistory/ID = 64
RearPnCCDIntegralHistory/HistName = RearPnCCDIntegralMedian
RearPnCCDIntegralHistory/Size = 10000

; deviation of integral from its median an the history of this value
[PostProcessor]
RearPnCCDIntegralDeviation/ID = 20
RearPnCCDIntegralDeviation/HistOne = RearPnCCDIntegral
RearPnCCDIntegralDeviation/HistTwo = RearPnCCDIntegralMedian
RearPnCCDIntegralDeviation/Hide = true
RearPnCCDIntegralHistory/ID = 64
RearPnCCDIntegralHistory/HistName = RearPnCCDIntegralDeviation
RearPnCCDIntegralHistory/Size = 10000

; a hit is found when the deviation is exceeding a given limit
[PostProcessor]
IsHit/ID = 9
IsHit/HistName = RearPnCCDIntegralDeviation
IsHit/UpperLimit = 1e20
IsHit/LowerLimit = 350000                   ;! limit that needs to be exceeded
IsHit/Hide = true

; its a non hit when its not a hit
[PostProcessor]
IsNotHit/ID = 4
IsNotHit/HistName = IsHit
IsNotHit/Hide = true

; hit rate: average of the isHit over so many shots
[PostProcessor]
HitRate/ID = 61
HitRate/HistName = IsHit
HitRate/NbrOfAverages = 800                 ;! how many shots should be averaged


;--------- things done with the images when its a hit / not a hit--------------

; the detector images when there is a hit
[PostProcessor]
RearPnCCDIsHit/ID = 55
RearPnCCDIsHit/HistName = RearPnCCD_
RearPnCCDIsHit/Operation = 90DegCCW
RearPnCCDIsHit/ConditionName = IsHit
[PostProcessor]
FrontPnCCDIsHit/ID = 55
FrontPnCCDIsHit/HistName = FrontPnCCD_
FrontPnCCDIsHit/Operation = 90DegCCW
FrontPnCCDIsHit/ConditionName = IsHit


;make an average of the rear pnccd detector image when its not a hit
[PostProcessor]
RearPnCCDNotHitAverage/ID = 61
RearPnCCDNotHitAverage/HistName = RearPnCCD
RearPnCCDNotHitAverage/NbrOfAverages = 100                 ;! set nbr of averages
RearPnCCDNotHitAverage/ConditionName = IsNotHit

;substract the current image from the average image when its a hit
[PostProcessor]
RearPnCCDIsHitCleared/ID = 20
RearPnCCDIsHitCleared/HistOne = RearPnCCD
RearPnCCDIsHitCleared/HistTwo = RearPnCCDNotHitAverage
RearPnCCDIsHitCleared/ConditionName = IsHit

;threshold the substracted image
[PostProcessor]
RearPnCCDIsHitClearedThresh/ID = 40
RearPnCCDIsHitClearedThresh/HistName = RearPnCCDIsHitCleared
RearPnCCDIsHitClearedThresh/Threshold = 10                ; The threshold
RearPnCCDIsHitClearedThresh/ConditionName = IsHit







;---------------------------program control and setup------------------------------------

;disable the pre analyzers as their functionality is ported to the new framework
[PreAnalyzer]
useCommercialCCDAnalyzer = false
usepnCCDAnalyzer = false

; only extract pnCCD and machine data from the stream
[Converter]
Used = pixeldetector,Machine

; what output level should be written into the log file
[Log]
LoggingLevel = "INFO"



;------------------definition of the rear detector-------------------
[PixelDetectors]
RearPnCCD/Detector = 1

; set up the hll like processing (removes offset and applies the mask)
RearPnCCD/FrameProcessorType = "hll" ; use hll like treating of the frame
RearPnCCD/HLLProcessing/CommonModeCalculationType = "simpleMean"
RearPnCCD/HLLProcessing/CommonModeCorrection/Width = 128
RearPnCCD/HLLProcessing/CommonModeCorrection/Multiplier = 4
RearPnCCD/HLLProcessing/SimpleMeanCommonMode/MinNbrPixels = 8
; set up the correction maps used with the hll type processing
RearPnCCD/CorrectionMaps/NoisyPixelThreshold = 100              ; add all pixels to the mask, whose noise exceeds this value
RearPnCCD/CorrectionMaps/MapCreatorType = "onlinecommonmode"  ; fast calculation with fixed amount of events taken to create the correction maps. Optionally remove the the common mode before calculting the offset and noise
RearPnCCD/CorrectionMaps/FixedOnlineCreatorCommonMode/NbrFrames = 200
RearPnCCD/CorrectionMaps/FixedOnlineCreatorCommonMode/WriteMaps = true
RearPnCCD/CorrectionMaps/FixedOnlineCreatorCommonMode/Multiplier = 40  ; if the individual pixel is this times higher than the average noise it will not be included in the calculation of the map
RearPnCCD/CorrectionMaps/FixedOnlineCreatorCommonMode/CommonModeCalculationType = "none"

; the below is not beeing used as there are no pp defined that will extract the list of pixels (coalesced pixels)

RearPnCCD/PixelFinderType = "range"              ; when a pp uses the list of pixels, it will give back the list of pixels that are within the given range
RearPnCCD/InRangeFinder/LowerThreshold = 220
RearPnCCD/InRangeFinder/UpperThreshold = 1e6

RearPnCCD/CoalescingFunctionType = "simple"      ; special pp use this if you want to have the found pixels coalesced.
RearPnCCD/SimpleCoalescing/MaxPixelListSize = 10000
RearPnCCD/SimpleCoalescing/MipThreshold = 1e6
RearPnCCD/SimpleCoalescing/MaxRecursionDepth = 100


; the mask elements
RearPnCCD/CorrectionMaps/Mask/size = 0

; example mask types
RearPnCCD/CorrectionMaps/Mask/1/MaskElementType = "circle"
RearPnCCD/CorrectionMaps/Mask/1/CenterX = 500
RearPnCCD/CorrectionMaps/Mask/1/CenterY = 500
RearPnCCD/CorrectionMaps/Mask/1/Radius = 100
RearPnCCD/CorrectionMaps/Mask/2/MaskElementType = "square"
RearPnCCD/CorrectionMaps/Mask/2/LowerLeftX = 10
RearPnCCD/CorrectionMaps/Mask/2/LowerLeftY = 10
RearPnCCD/CorrectionMaps/Mask/2/UpperRightX = 90
RearPnCCD/CorrectionMaps/Mask/2/UpperRightY = 90
RearPnCCD/CorrectionMaps/Mask/3/MaskElementType = "ellipse"
RearPnCCD/CorrectionMaps/Mask/3/CenterX = 500
RearPnCCD/CorrectionMaps/Mask/3/CenterY = 500
RearPnCCD/CorrectionMaps/Mask/3/SemiAxisX = 50
RearPnCCD/CorrectionMaps/Mask/3/SemiAxisY = 10
RearPnCCD/CorrectionMaps/Mask/4/MaskElementType = "triangle"
RearPnCCD/CorrectionMaps/Mask/4/PointA_X = 10
RearPnCCD/CorrectionMaps/Mask/4/PointA_Y = 10
RearPnCCD/CorrectionMaps/Mask/4/PointB_X = 20
RearPnCCD/CorrectionMaps/Mask/4/PointB_Y = 10
RearPnCCD/CorrectionMaps/Mask/4/PointC_X = 10
RearPnCCD/CorrectionMaps/Mask/4/PointC_Y = 20



;------------------definition of the Front detector-------------------
[PixelDetectors]
FrontPnCCD/Detector = 0

; set up the hll like processing (removes offset and applies the mask)
FrontPnCCD/FrameProcessorType = "hll" ; use hll like treating of the frame
FrontPnCCD/HLLProcessing/CommonModeCalculationType = "simpleMean"
FrontPnCCD/HLLProcessing/CommonModeCorrection/Width = 128
FrontPnCCD/HLLProcessing/CommonModeCorrection/Multiplier = 4
FrontPnCCD/HLLProcessing/SimpleMeanCommonMode/MinNbrPixels = 8
; set up the correction maps used with the hll type processing
FrontPnCCD/CorrectionMaps/NoisyPixelThreshold = 100              ; add all pixels to the mask, whose noise exceeds this value
FrontPnCCD/CorrectionMaps/MapCreatorType = "onlinecommonmode"  ; fast calculation with fixed amount of events taken to create the correction maps. Optionally remove the the common mode before calculting the offset and noise
FrontPnCCD/CorrectionMaps/FixedOnlineCreatorCommonMode/NbrFrames = 200
FrontPnCCD/CorrectionMaps/FixedOnlineCreatorCommonMode/WriteMaps = true
FrontPnCCD/CorrectionMaps/FixedOnlineCreatorCommonMode/Multiplier = 40  ; if the individual pixel is this times higher than the average noise it will not be included in the calculation of the map
FrontPnCCD/CorrectionMaps/FixedOnlineCreatorCommonMode/CommonModeCalculationType = "none"

; the below is not beeing used as there are no pp defined that will extract the list of pixels (coalesced pixels)

FrontPnCCD/PixelFinderType = "range"              ; when a pp uses the list of pixels, it will give back the list of pixels that are within the given range
FrontPnCCD/InRangeFinder/LowerThreshold = 220
FrontPnCCD/InRangeFinder/UpperThreshold = 1e6

FrontPnCCD/CoalescingFunctionType = "simple"      ; special pp use this if you want to have the found pixels coalesced.
FrontPnCCD/SimpleCoalescing/MaxPixelListSize = 10000
FrontPnCCD/SimpleCoalescing/MipThreshold = 1e6
FrontPnCCD/SimpleCoalescing/MaxRecursionDepth = 100


; the mask elements
FrontPnCCD/CorrectionMaps/Mask/size = 0

; example mask types
FrontPnCCD/CorrectionMaps/Mask/1/MaskElementType = "circle"
FrontPnCCD/CorrectionMaps/Mask/1/CenterX = 500
FrontPnCCD/CorrectionMaps/Mask/1/CenterY = 500
FrontPnCCD/CorrectionMaps/Mask/1/Radius = 100
FrontPnCCD/CorrectionMaps/Mask/2/MaskElementType = "square"
FrontPnCCD/CorrectionMaps/Mask/2/LowerLeftX = 10
FrontPnCCD/CorrectionMaps/Mask/2/LowerLeftY = 10
FrontPnCCD/CorrectionMaps/Mask/2/UpperRightX = 90
FrontPnCCD/CorrectionMaps/Mask/2/UpperRightY = 90
FrontPnCCD/CorrectionMaps/Mask/3/MaskElementType = "ellipse"
FrontPnCCD/CorrectionMaps/Mask/3/CenterX = 500
FrontPnCCD/CorrectionMaps/Mask/3/CenterY = 500
FrontPnCCD/CorrectionMaps/Mask/3/SemiAxisX = 50
FrontPnCCD/CorrectionMaps/Mask/3/SemiAxisY = 10
FrontPnCCD/CorrectionMaps/Mask/4/MaskElementType = "triangle"
FrontPnCCD/CorrectionMaps/Mask/4/PointA_X = 10
FrontPnCCD/CorrectionMaps/Mask/4/PointA_Y = 10
FrontPnCCD/CorrectionMaps/Mask/4/PointB_X = 20
FrontPnCCD/CorrectionMaps/Mask/4/PointB_Y = 10
FrontPnCCD/CorrectionMaps/Mask/4/PointC_X = 10
FrontPnCCD/CorrectionMaps/Mask/4/PointC_Y = 20

