;;
;; This example shows how to do hitfinding when there is only the pnCCDs present.
;; Basically it uses the same algorith that is used in singleParticleDetection_new.ini.
;; In addition it will also display the last 6 hits that were identified.
;; The rear detector is rotated such that the gap is vertical, therefore
;; one has to rotate the data by 180 Degree.
;;


; ---------------------the postprocessors--------------------------

;----------------the raw images / tof traces-----------------------


; The rear detector image
[PostProcessor]
RearPnCCDNotRotated/ID = 105
RearPnCCDNotRotated/Detector = RearPnCCD
RearPnCCDNotRotated/Write = false

; offset map rear detector
[PostProcessor]
RearPnCCDNotRotatedOffsetMap/ID = 107
RearPnCCDNotRotatedOffsetMap/Detector = RearPnCCD
RearPnCCDNotRotatedOffsetMap/MapType = offset
RearPnCCDNotRotatedOffsetMap/Write = false

; noise map rear detector
[PostProcessor]
RearPnCCDNotRotatedNoiseMap/ID = 107
RearPnCCDNotRotatedNoiseMap/Detector = RearPnCCD
RearPnCCDNotRotatedNoiseMap/MapType = noise
RearPnCCDNotRotatedNoiseMap/Write = false

; mask rear detector
[PostProcessor]
RearPnCCDNotRotatedGain/ID = 107
RearPnCCDNotRotatedGain/Detector = RearPnCCD
RearPnCCDNotRotatedGain/MapType = correction
RearPnCCDNotRotatedGain/Write = false



; The front detector image
[PostProcessor]
FrontPnCCDNotRotated/ID = 105
FrontPnCCDNotRotated/Detector = FrontPnCCD
FrontPnCCDNotRotated/Write = false

; offset map Front detector
[PostProcessor]
FrontPnCCDOffsetMapNotRotated/ID = 107
FrontPnCCDOffsetMapNotRotated/Detector = FrontPnCCD
FrontPnCCDOffsetMapNotRotated/MapType = offset
FrontPnCCDOffsetMapNotRotated/Write = false

; noise map Front detector
[PostProcessor]
FrontPnCCDNoiseMapNotRotated/ID = 107
FrontPnCCDNoiseMapNotRotated/Detector = FrontPnCCD
FrontPnCCDNoiseMapNotRotated/MapType = noise
FrontPnCCDNoiseMapNotRotated/Write = false

; mask Front detector
[PostProcessor]
FrontPnCCDGainNotRotated/ID = 107
FrontPnCCDGainNotRotated/Detector = FrontPnCCD
FrontPnCCDGainNotRotated/MapType = correction
FrontPnCCDGainNotRotated/Write = false



; ToF trace
[PostProcessor]
ToF/ID = 110
ToF/Write = false
ToF/InstrumentId = 3
ToF/ChannelNbr = 1
ToF/Write = false

; Diode trace
[PostProcessor]
Diode/ID = 110
Diode/Write = false
Diode/InstrumentId = 3
Diode/ChannelNbr = 0
Diode/Write = false





;------------- definitions of when a hit is found------------------


; an integral over a certain region of the rear detector
; done by projecting a given range on the x-axis and then taking
; the integral of the projection within a certain range of the axis
; substract the median of the integral from the integral and use
; the substracted to find the hit
[PostProcessor]
RearPnCCDProject/ID = 50
RearPnCCDProject/HistName = RearPnCCDNotRotated
RearPnCCDProject/LowerBound = 300                            ;! y range form where
RearPnCCDProject/UpperBound = 750                            ;! y range to where
RearPnCCDProject/Axis = 0                                    ; project to x axis
RearPnCCDProject/Hide = true
RearPnCCDProject/Write = false
RearPnCCDAreaIntegral/ID = 51
RearPnCCDAreaIntegral/HistName = RearPnCCDProject
RearPnCCDAreaIntegral/LowerBound = 200                       ; x range from where
RearPnCCDAreaIntegral/UpperBound = 480                       ; x range to where
RearPnCCDAreaIntegral/Hide = true
RearPnCCDAreaIntegral/Write = false
RearPnCCDIntegralMedian/ID = 301
RearPnCCDIntegralMedian/MedianSize = 10
RearPnCCDIntegralMedian/HistName = RearPnCCDAreaIntegral
RearPnCCDIntegralMedian/Hide = true
RearPnCCDIntegralMedian/Write = false
RearPnCCDIntegralDeviation/ID = 20
RearPnCCDIntegralDeviation/HistOne = RearPnCCDAreaIntegral
RearPnCCDIntegralDeviation/HistTwo = RearPnCCDIntegralMedian
RearPnCCDIntegralDeviation/Hide = true
RearPnCCDIntegralDeviation/Write = false
RearPnCCDIntegralDeviationHistory/ID = 64
RearPnCCDIntegralDeviationHistory/HistName = RearPnCCDIntegralDeviation
RearPnCCDIntegralDeviationHistory/Size = 5000
RearPnCCDIntegralDeviationHistory/Write = false
RearPnCCDHitfinder/ID = 9
RearPnCCDHitfinder/HistName = RearPnCCDIntegralDeviation
RearPnCCDHitfinder/UpperLimit = 1e20
RearPnCCDHitfinder/LowerLimit = 80000                   ;! limit that needs to be exceeded
RearPnCCDHitfinder/Hide = true
RearPnCCDHitfinder/Write = false




; an integral over a certain region of the front detector
; done by projecting a given range on the x-axis and then taking
; the integral of the projection within a certain range of the axis
; substract the median of the integral from the integral and use
; the substracted to find the hit
[PostProcessor]
FrontPnCCDProject/ID = 50
FrontPnCCDProject/HistName = FrontPnCCDNotRotated
FrontPnCCDProject/LowerBound = 300                            ;! y range form where
FrontPnCCDProject/UpperBound = 750                            ;! y range to where
FrontPnCCDProject/Axis = 0                                    ; project to x axis
FrontPnCCDProject/Hide = true
FrontPnCCDProject/Write = false
FrontPnCCDAreaIntegral/ID = 51
FrontPnCCDAreaIntegral/HistName = FrontPnCCDProject
FrontPnCCDAreaIntegral/LowerBound = 200                       ; x range from where
FrontPnCCDAreaIntegral/UpperBound = 480                       ; x range to where
FrontPnCCDAreaIntegral/Hide = true
FrontPnCCDAreaIntegral/Write = false
FrontPnCCDIntegralMedian/ID = 301
FrontPnCCDIntegralMedian/MedianSize = 10
FrontPnCCDIntegralMedian/HistName = FrontPnCCDAreaIntegral
FrontPnCCDIntegralMedian/Hide = true
FrontPnCCDIntegralMedian/Write = false
FrontPnCCDIntegralDeviation/ID = 20
FrontPnCCDIntegralDeviation/HistOne = FrontPnCCDAreaIntegral
FrontPnCCDIntegralDeviation/HistTwo = FrontPnCCDIntegralMedian
FrontPnCCDIntegralDeviation/Hide = true
FrontPnCCDIntegralDeviation/Write = false
FrontPnCCDIntegralDeviationHistory/ID = 64
FrontPnCCDIntegralDeviationHistory/HistName = FrontPnCCDIntegralDeviation
FrontPnCCDIntegralDeviationHistory/Size = 5000
FrontPnCCDIntegralDeviationHistory/Write = false
FrontPnCCDHitfinder/ID = 9
FrontPnCCDHitfinder/HistName = FrontPnCCDIntegralDeviation
FrontPnCCDHitfinder/UpperLimit = 1e20
FrontPnCCDHitfinder/LowerLimit = 35000                   ;! limit that needs to be exceeded
FrontPnCCDHitfinder/Hide = true
FrontPnCCDHitfinder/Write = false







; define which of the hitfinders defined above will be used as hit
; identification for the later PostProcessors by ANDing this with
; true. Then one can use the IsHit PostProcessor later on, by only
; chaning here which condition to use.
[PostProcessor]
IsHit/ID = 5
IsHit/HistOne = DefaultTrueHist
IsHit/HistTwo = RearPnCCDHitfinder
;IsHit/HistTwo = FrontPnCCDHitfinder
IsHit/Hide = true
IsHit/Write = false

; define its a non hit when its not a hit
[PostProcessor]
IsNotHit/ID = 4
IsNotHit/HistName = IsHit
IsNotHit/Hide = true
IsNotHit/Write = false

; display the hit rate: average of the isHit over so many shots
[PostProcessor]
HitRate/ID = 61
HitRate/HistName = IsHit
HitRate/NbrOfAverages = 1000        ;! how many shots should be averaged
HitRate/Hide = true
HitRate/Write = false
HitRateHistory/ID = 64
HitRateHistory/HistName = HitRate
HitRateHistory/Size = 5000
HitRateHistory/Write = false



;--------------- things done when there is a hit-------------------

; the rear pnccd images when there is a hit
[PostProcessor]
RearPnCCDIsHit/ID = 55
RearPnCCDIsHit/HistName = RearPnCCDNotRotated
RearPnCCDIsHit/Operation = 180Deg
RearPnCCDIsHit/ConditionName = IsHit
RearPnCCDIsHit/Write = true

; Average rear pnccd image when its not a hit and substract it
; from the current image, to clear the image from background
[PostProcessor]
RearPnCCDNotRotatedIsNotHitAve/ID = 61
RearPnCCDNotRotatedIsNotHitAve/HistName = RearPnCCDNotRotated
RearPnCCDNotRotatedIsNotHitAve/NbrOfAverages = 200
RearPnCCDNotRotatedIsNotHitAve/ConditionName = IsNotHit
RearPnCCDNotRotatedIsNotHitAve/Write = false
RearPnCCDNotRotatedIsHitCleared/ID = 20
RearPnCCDNotRotatedIsHitCleared/HistOne = RearPnCCDNotRotated
RearPnCCDNotRotatedIsHitCleared/HistTwo = RearPnCCDNotRotatedIsNotHitAve
RearPnCCDNotRotatedIsHitCleared/ConditionName = IsHit
RearPnCCDNotRotatedIsHitCleared/Hide = true
RearPnCCDNotRotatedIsHitCleared/Write = false
RearPnCCDIsHitCleared/ID = 55
RearPnCCDIsHitCleared/HistName = RearPnCCDNotRotatedIsHitCleared
RearPnCCDIsHitCleared/Operation = 180Deg
RearPnCCDIsHitCleared/ConditionName = IsHit
RearPnCCDIsHitCleared/Write = true

; remember the hit of the previous events
[PostProcessor]
RearPnCCDIsHitClearedMinus1/ID = 56
RearPnCCDIsHitClearedMinus1/HistName = RearPnCCDIsHitCleared
RearPnCCDIsHitClearedMinus1/ConditionName = IsHit
RearPnCCDIsHitClearedMinus1/Write = false
RearPnCCDIsHitClearedMinus2/ID = 56
RearPnCCDIsHitClearedMinus2/HistName = RearPnCCDIsHitClearedMinus1
RearPnCCDIsHitClearedMinus2/ConditionName = IsHit
RearPnCCDIsHitClearedMinus2/Write = false
RearPnCCDIsHitClearedMinus3/ID = 56
RearPnCCDIsHitClearedMinus3/HistName = RearPnCCDIsHitClearedMinus2
RearPnCCDIsHitClearedMinus3/ConditionName = IsHit
RearPnCCDIsHitClearedMinus3/Write = false
RearPnCCDIsHitClearedMinus4/ID = 56
RearPnCCDIsHitClearedMinus4/HistName = RearPnCCDIsHitClearedMinus3
RearPnCCDIsHitClearedMinus4/ConditionName = IsHit
RearPnCCDIsHitClearedMinus4/Write = false
RearPnCCDIsHitClearedMinus5/ID = 56
RearPnCCDIsHitClearedMinus5/HistName = RearPnCCDIsHitClearedMinus4
RearPnCCDIsHitClearedMinus5/ConditionName = IsHit
RearPnCCDIsHitClearedMinus5/Write = false




; the front pnccd images when there is a hit
[PostProcessor]
FrontPnCCDIsHit/ID = 55
FrontPnCCDIsHit/HistName = FrontPnCCDNotRotated
FrontPnCCDIsHit/Operation = 90DegCCW
FrontPnCCDIsHit/ConditionName = IsHit
FrontPnCCDIsHit/Write = true

; Average front pnccd image when its not a hit and substract it
; from the current image, to clear the image from background
[PostProcessor]
FrontPnCCDNotRotatedIsNotHitAve/ID = 61
FrontPnCCDNotRotatedIsNotHitAve/HistName = FrontPnCCDNotRotated
FrontPnCCDNotRotatedIsNotHitAve/NbrOfAverages = 200
FrontPnCCDNotRotatedIsNotHitAve/ConditionName = IsNotHit
FrontPnCCDNotRotatedIsNotHitAve/Write = false
FrontPnCCDIsHitClearedNotRotated/ID = 20
FrontPnCCDIsHitClearedNotRotated/HistOne = FrontPnCCDNotRotated
FrontPnCCDIsHitClearedNotRotated/HistTwo = FrontPnCCDNotRotatedIsNotHitAve
FrontPnCCDIsHitClearedNotRotated/ConditionName = IsHit
FrontPnCCDIsHitClearedNotRotated/Hide = true
FrontPnCCDIsHitClearedNotRotated/Write = false
FrontPnCCDIsHitCleared/ID = 55
FrontPnCCDIsHitCleared/HistName = FrontPnCCDIsHitClearedNotRotated
FrontPnCCDIsHitCleared/Operation = 90DegCCW
FrontPnCCDIsHitCleared/ConditionName = IsHit
FrontPnCCDIsHitCleared/Write = true

FrontPnCCDIsHitMinus1
; remember the hit of the previous events
[PostProcessor]
FrontPnCCDIsHitClearedMinus1/ID = 56
FrontPnCCDIsHitClearedMinus1/HistName = FrontPnCCDIsHitCleared
FrontPnCCDIsHitClearedMinus1/ConditionName = IsHit
FrontPnCCDIsHitClearedMinus1/Write = false
FrontPnCCDIsHitClearedMinus2/ID = 56
FrontPnCCDIsHitClearedMinus2/HistName = FrontPnCCDIsHitClearedMinus1
FrontPnCCDIsHitClearedMinus2/ConditionName = IsHit
FrontPnCCDIsHitClearedMinus2/Write = false
FrontPnCCDIsHitClearedMinus3/ID = 56
FrontPnCCDIsHitClearedMinus3/HistName = FrontPnCCDIsHitClearedMinus2
FrontPnCCDIsHitClearedMinus3/ConditionName = IsHit
FrontPnCCDIsHitClearedMinus3/Write = false
FrontPnCCDIsHitClearedMinus4/ID = 56
FrontPnCCDIsHitClearedMinus4/HistName = FrontPnCCDIsHitClearedMinus3
FrontPnCCDIsHitClearedMinus4/ConditionName = IsHit
FrontPnCCDIsHitClearedMinus4/Write = false
FrontPnCCDIsHitClearedMinus5/ID = 56
FrontPnCCDIsHitClearedMinus5/HistName = FrontPnCCDIsHitClearedMinus4
FrontPnCCDIsHitClearedMinus5/ConditionName = IsHit
FrontPnCCDIsHitClearedMinus5/Write = false



; the tof trace
[PostProcessor]
ToFIsHit/ID = 110
ToFIsHit/InstrumentId = 3
ToFIsHit/ChannelNbr = 1
ToFIsHit/ConditionName = IsHit
ToFIsHit/Write = true

; the diode trace
[PostProcessor]
DiodeIsHit/ID = 110
DiodeIsHit/InstrumentId = 3
DiodeIsHit/ChannelNbr = 1
DiodeIsHit/ConditionName = IsHit
DiodeIsHit/Write = true


;-------------------program control and setup----------------------

;disable the pre analyzers as their functionality is ported to the new framework
[PreAnalyzer]
useCommercialCCDAnalyzer = false
usepnCCDAnalyzer = false

; only extract pnCCD, other camera data and machine data from the stream
[Converter]
Used = pixeldetector,Machine,Acqiris

; what output level should be written into the log file
[Log]
LoggingLevel = "INFO"



;------------------definition of the rear detector-----------------
[PixelDetectors]
RearPnCCD/Detector = 1                                                                   ; detector id

; set up the hll like processing (removes offset and applies the mask)
RearPnCCD/FrameProcessorType = "hll"
RearPnCCD/HLLProcessing/CommonModeCalculationType = "none"                               ; no commonmode correction
; set up the correction maps used with the hll type processing
RearPnCCD/CorrectionMaps/NoisyPixelThreshold = 4.5                                       ; add all pixels to the mask, whose noise exceeds this value
RearPnCCD/CorrectionMaps/MapCreatorType = "onlinecommonmode"                             ; fast calculation with fixed amount of events taken to create the correction maps. Optionally remove the the common mode before calculting the offset and noise
RearPnCCD/CorrectionMaps/FixedOnlineCreatorCommonMode/NbrFrames = 200                    ; the number of frames included for the darkcalibration
RearPnCCD/CorrectionMaps/FixedOnlineCreatorCommonMode/WriteMaps = true                   ; write the calculated maps to file.
RearPnCCD/CorrectionMaps/FixedOnlineCreatorCommonMode/Multiplier = 4                     ; if the individual pixel is this times higher than the average noise it will not be included in the calculation of the map
RearPnCCD/CorrectionMaps/FixedOnlineCreatorCommonMode/CommonModeCalculationType = "none" ; no common mode correction when creation offset / noise maps
RearPnCCD/CorrectionMaps/InputOffsetNoiseFiletype = "hll"                                ; The calibration file is in the hll file format.
RearPnCCD/CorrectionMaps/InputOffsetNoiseFilename = "darkcal_1.lnk"                      ; default name. The link should point to the latest darkcalibration file.


; the mask elements
RearPnCCD/CorrectionMaps/Mask/size = 0                     ; the number of mask elements that will result in the final mask
; example mask types
RearPnCCD/CorrectionMaps/Mask/1/MaskElementType = "circle"
RearPnCCD/CorrectionMaps/Mask/1/CenterX = 500
RearPnCCD/CorrectionMaps/Mask/1/CenterY = 500
RearPnCCD/CorrectionMaps/Mask/1/Radius = 100
RearPnCCD/CorrectionMaps/Mask/2/MaskElementType = "square"
RearPnCCD/CorrectionMaps/Mask/2/LowerLeftX = 10
RearPnCCD/CorrectionMaps/Mask/2/LowerLeftY = 10
RearPnCCD/CorrectionMaps/Mask/2/UpperRightX = 90
RearPnCCD/CorrectionMaps/Mask/2/UpperRightY = 90
RearPnCCD/CorrectionMaps/Mask/3/MaskElementType = "ellipse"
RearPnCCD/CorrectionMaps/Mask/3/CenterX = 500
RearPnCCD/CorrectionMaps/Mask/3/CenterY = 500
RearPnCCD/CorrectionMaps/Mask/3/SemiAxisX = 50
RearPnCCD/CorrectionMaps/Mask/3/SemiAxisY = 10
RearPnCCD/CorrectionMaps/Mask/4/MaskElementType = "triangle"
RearPnCCD/CorrectionMaps/Mask/4/PointA_X = 10
RearPnCCD/CorrectionMaps/Mask/4/PointA_Y = 10
RearPnCCD/CorrectionMaps/Mask/4/PointB_X = 20
RearPnCCD/CorrectionMaps/Mask/4/PointB_Y = 10
RearPnCCD/CorrectionMaps/Mask/4/PointC_X = 10
RearPnCCD/CorrectionMaps/Mask/4/PointC_Y = 20



;------------------definition of the Front detector----------------
[PixelDetectors]
FrontPnCCD/Detector = 0                                                                   ; detector id

; set up the hll like processing (removes offset and applies the mask)
FrontPnCCD/FrameProcessorType = "hll"
;FrontPnCCD/FrameProcessorType = "none"
FrontPnCCD/HLLProcessing/CommonModeCalculationType = "none"                               ; no commonmode correction
; set up the correction maps used with the hll type processing
FrontPnCCD/CorrectionMaps/NoisyPixelThreshold = 4.5                                       ; add all pixels to the mask, whose noise exceeds this value
FrontPnCCD/CorrectionMaps/MapCreatorType = "onlinecommonmode"                             ; fast calculation with fixed amount of events taken to create the correction maps. Optionally remove the the common mode before calculting the offset and noise
FrontPnCCD/CorrectionMaps/FixedOnlineCreatorCommonMode/NbrFrames = 200                    ; the number of frames included for the darkcalibration
FrontPnCCD/CorrectionMaps/FixedOnlineCreatorCommonMode/WriteMaps = true                   ; write the calculated maps to file.
FrontPnCCD/CorrectionMaps/FixedOnlineCreatorCommonMode/Multiplier = 4                     ; if the individual pixel is this times higher than the average noise it will not be included in the calculation of the map
FrontPnCCD/CorrectionMaps/FixedOnlineCreatorCommonMode/CommonModeCalculationType = "none" ; no common mode correction when creation offset / noise maps
FrontPnCCD/CorrectionMaps/InputOffsetNoiseFiletype = "hll"                                ; The calibration file is in the hll file format.
FrontPnCCD/CorrectionMaps/InputOffsetNoiseFilename = "darkcal_0.lnk"                      ; default name. The link should point to the latest darkcalibration file.

; the mask elements
FrontPnCCD/CorrectionMaps/Mask/size = 0                                                   ; the number of mask elements that will result in the final mask
FrontPnCCD/CorrectionMaps/Mask/1/MaskElementType = "square"
FrontPnCCD/CorrectionMaps/Mask/1/LowerLeftX = 490
FrontPnCCD/CorrectionMaps/Mask/1/LowerLeftY = 500
FrontPnCCD/CorrectionMaps/Mask/1/UpperRightX = 700
FrontPnCCD/CorrectionMaps/Mask/1/UpperRightY = 1023


; example mask types
;FrontPnCCD/CorrectionMaps/Mask/1/MaskElementType = "circle"
;FrontPnCCD/CorrectionMaps/Mask/1/CenterX = 500
;FrontPnCCD/CorrectionMaps/Mask/1/CenterY = 500
;FrontPnCCD/CorrectionMaps/Mask/1/Radius = 100
;FrontPnCCD/CorrectionMaps/Mask/2/MaskElementType = "square"
;FrontPnCCD/CorrectionMaps/Mask/2/LowerLeftX = 10
;FrontPnCCD/CorrectionMaps/Mask/2/LowerLeftY = 10
;FrontPnCCD/CorrectionMaps/Mask/2/UpperRightX = 90
;FrontPnCCD/CorrectionMaps/Mask/2/UpperRightY = 90
;FrontPnCCD/CorrectionMaps/Mask/3/MaskElementType = "ellipse"
;FrontPnCCD/CorrectionMaps/Mask/3/CenterX = 500
;FrontPnCCD/CorrectionMaps/Mask/3/CenterY = 500
;FrontPnCCD/CorrectionMaps/Mask/3/SemiAxisX = 50
;FrontPnCCD/CorrectionMaps/Mask/3/SemiAxisY = 10
;FrontPnCCD/CorrectionMaps/Mask/4/MaskElementType = "triangle"
;FrontPnCCD/CorrectionMaps/Mask/4/PointA_X = 10
;FrontPnCCD/CorrectionMaps/Mask/4/PointA_Y = 10
;FrontPnCCD/CorrectionMaps/Mask/4/PointB_X = 20
;FrontPnCCD/CorrectionMaps/Mask/4/PointB_Y = 10
;FrontPnCCD/CorrectionMaps/Mask/4/PointC_X = 10
;FrontPnCCD/CorrectionMaps/Mask/4/PointC_Y = 20

