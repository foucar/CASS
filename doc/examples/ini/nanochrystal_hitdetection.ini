;
; this example shows how to detect whether a pnCCD frame contains a nanochrystal
; hit. As input it uses the tcp input.
;

; general setup

[TCPInput]
Server = 192.168.0.190
Port = 9090
DataType = "shm"

;disable the pre analyzers as their functionality is ported to the new framework
[PreAnalyzer]
useCommercialCCDAnalyzer = false
usepnCCDAnalyzer = false

;setup the pnCCD

;;---------------------The Filter -------------------------------------------
[PixelDetectors]
FilterPnCCD/Detector = 0                       ; 0: Front pnCCD detector

;FilterPnCCD/FrameProcessorType = "none"        ; none: Just use the raw image

FilterPnCCD/FrameProcessorType = "hll"         ; hll: HLL type processing
FilterPnCCD/HLLProcessing/CommonModeCalculationType = "none"
;FilterPnCCD/HLLProcessing/CommonModeCalculationType = "simpleMean"
;FilterPnCCD/HLLProcessing/CommonModeCalculationType = "mean"
;FilterPnCCD/HLLProcessing/CommonModeCalculationType = "median"
FilterPnCCD/HLLProcessing/CommonModeCorrection/Width = 128
FilterPnCCD/HLLProcessing/CommonModeCorrection/Multiplier = 4
FilterPnCCD/HLLProcessing/SimpleMeanCommonMode/MinNbrPixels = 8

FilterPnCCD/PixelFinderType = "aboveNoise"     ; uses noise map to identify pixels
FilterPnCCD/AboveNoiseFinder/Multiplier = 4

FilterPnCCD/CoalescingFunctionType = "simple"  ; simple coalscing of pixels
FilterPnCCD/SimpleCoalescing/MaxPixelListSize = 10000 ; if there are more than this amount of pixels in the frame skip the coalscing
FilterPnCCD/SimpleCoalescing/MipThreshold = 1e6       ; if one pixel has a value higher than this than the hit is regarded as "ionizing particle" and skipped
FilterPnCCD/SimpleCoalescing/MaxRecursionDepth = 7    ; how deep will the recursive algorithm go

;FilterPnCCD/CorrectionMaps/NoisyPixelThreshold = 40 ; all pixels which noises are bigger than this value will be added to the mask

FilterPnCCD/CorrectionMaps/MapCreatorType = "online"  ; fast calculation with fixed amount of events taken to create the correction maps
FilterPnCCD/CorrectionMaps/FixedOnlineCreator/NbrFrames = 100
FilterPnCCD/CorrectionMaps/FixedOnlineCreator/WriteMaps = true
FilterPnCCD/CorrectionMaps/FixedOnlineCreator/Multiplier = 40
;FilterPnCCD/CorrectionMaps/FixedOnlineCreator/StartInstantly = true

FilterPnCCD/CorrectionMaps/Mask/size = 1
FilterPnCCD/CorrectionMaps/Mask/1/MaskElementType = "ring"
FilterPnCCD/CorrectionMaps/Mask/1/OuterCenterX = 500
FilterPnCCD/CorrectionMaps/Mask/1/OuterCenterY = 500
FilterPnCCD/CorrectionMaps/Mask/1/OuterSemiAxisX = 300
FilterPnCCD/CorrectionMaps/Mask/1/OuterSemiAxisY = 200
FilterPnCCD/CorrectionMaps/Mask/1/InnerCenterX = 500
FilterPnCCD/CorrectionMaps/Mask/1/InnerCenterY = 500
FilterPnCCD/CorrectionMaps/Mask/1/InnerSemiAxisX = 50
FilterPnCCD/CorrectionMaps/Mask/1/InnerSemiAxisY = 200


;; ----------------- The image ------------------------------------------------
[PixelDetectors]
PnCCD/Detector = 0                       ; 0: Front pnCCD detector

PnCCD/FrameProcessorType = "hll"         ; hll: HLL type processing
PnCCD/HLLProcessing/CommonModeCalculationType = "none"
;PnCCD/HLLProcessing/CommonModeCalculationType = "simpleMean"
PnCCD/HLLProcessing/CommonModeCorrection/Width = 128
PnCCD/HLLProcessing/CommonModeCorrection/Multiplier = 4
PnCCD/HLLProcessing/SimpleMeanCommonMode/MinNbrPixels = 8



;---- postprocessors----

; the correction maps
[PostProcessor]
NoiseMap/ID = 107
NoiseMap/Detector = FilterPnCCD
NoiseMap/MapType = noise

[PostProcessor]
OffsetMap/ID = 107
OffsetMap/Detector = FilterPnCCD
OffsetMap/MapType = offset

[PostProcessor]
CorrMap/ID = 107
CorrMap/Detector = FilterPnCCD
CorrMap/MapType = correction


; the final images
[PostProcessor]
PnCCD/ID = 105
PnCCD/Detector = PnCCD
PnCCD/ConditionName = IsHit
PnCCDRot/ID = 55
PnCCDRot/HistName = PnCCD
PnCCDRot/Operation = 90DegCCW
PnCCDRot/ConditionName = IsHit



; the image to filter on
[PostProcessor]
FilterPnCCD/ID = 105
FilterPnCCD/Detector = FilterPnCCD


; histogram of all pixels
[PostProcessor]
Hist/ID = 106
Hist/Detector = FilterPnCCD
Hist/XNbrBins = 1000
Hist/XLow = 0
Hist/XUp = 16400
Hist/XTitle = pixel values [adu]

; histogram of non coalesced "photon" pixels
[PostProcessor]
PixelHist/ID = 147
PixelHist/Detector = FilterPnCCD
PixelHist/XNbrBins = 1000
PixelHist/XLow = 0
PixelHist/XUp = 16400
PixelHist/XTitle = pixel values [adu]

; image of non coalesced "photon" pixels as image (will add the pixel value
; at the position where the pixel was found
[PostProcessor]
PixelImage/ID = 148
PixelImage/Detector = FilterPnCCD
PixelImage/PixelvalueAsWeight = true
PixelImage/SpectralLowerLimit = 0
PixelImage/SpectralUpperLimit = 16400
PixelImage/XNbrBins = 256
PixelImage/XLow = 0
PixelImage/XUp = 1024
PixelImage/XTitle = columns
PixelImage/YNbrBins = 256
PixelImage/YLow = 0
PixelImage/YUp = 1024
PixelImage/YTitle = rows

; image of non coalesced "photon" pixels as histogram (will add just a 1
; at the position where the pixel was found
[PostProcessor]
PixelImageHist/ID = 148
PixelImageHist/Detector = FilterPnCCD
PixelImageHist/PixelvalueAsWeight = false
PixelImageHist/SpectralLowerLimit = 0
PixelImageHist/SpectralUpperLimit = 16400
PixelImageHist/XNbrBins = 256
PixelImageHist/XLow = 0
PixelImageHist/XUp = 1024
PixelImageHist/XTitle = columns
PixelImageHist/YNbrBins = 256
PixelImageHist/YLow = 0
PixelImageHist/YUp = 1024
PixelImageHist/YTitle = rows

[PostProcessor] ; the number of non coalesced "photon" pixels found
NbrPixels/ID = 149
NbrPixels/Detector = FilterPnCCD



[PostProcessor] ; histogram of the splitlevel of coalesced "photon" (hit)
HitSplitLvl/ID = 146
HitSplitLvl/Detector = FilterPnCCD
HitSplitLvl/XNbrBins = 80
HitSplitLvl/XLow = 0
HitSplitLvl/XUp = 40
HitSplitLvl/XTitle = pixel values [adu]

[PostProcessor] ; histogram of coalesced "photon" pixels (hits)
HitHist/ID = 143
HitHist/Detector = FilterPnCCD
HitHist/SplitLevelLowerLimit = 0
HitHist/SplitLevelUpperLimit = 10
HitHist/XNbrBins = 1000
HitHist/XLow = 0
HitHist/XUp = 16400
HitHist/XTitle = pixel values [adu]

; image of hits as image (will add the pixel value at the position 
; where the hit is)
[PostProcessor]
HitImage/ID = 144
HitImage/Detector = FilterPnCCD
HitImage/PixelvalueAsWeight = true
HitImage/SpectralLowerLimit = 0
HitImage/SpectralUpperLimit = 16400
HitImage/SplitLevelLowerLimit = 0
HitImage/SplitLevelUpperLimit = 10
HitImage/XNbrBins = 256
HitImage/XLow = 0
HitImage/XUp = 1024
HitImage/XTitle = columns
HitImage/YNbrBins = 256
HitImage/YLow = 0
HitImage/YUp = 1024
HitImage/YTitle = rows

; image of hits as histogram (will increment the position where the hit is by 1)
[PostProcessor]
HitImageHist/ID = 144
HitImageHist/Detector = FilterPnCCD
HitImageHist/PixelvalueAsWeight = false
HitImageHist/SpectralLowerLimit = 0
HitImageHist/SpectralUpperLimit = 16400
HitImageHist/SplitLevelLowerLimit = 0
HitImageHist/SplitLevelUpperLimit = 10
HitImageHist/XNbrBins = 256
HitImageHist/XLow = 0
HitImageHist/XUp = 1024
HitImageHist/XTitle = columns
HitImageHist/YNbrBins = 256
HitImageHist/YLow = 0
HitImageHist/YUp = 1024
HitImageHist/YTitle = rows

[PostProcessor] ; the number of coalesced "photon" pixels (hits) found
NbrHits/ID = 145
NbrHits/Detector = FilterPnCCD

;take interal over upper region of the hit sprectrum and make a history of it
[PostProcessor]
Integral/ID = 51
Integral/HistName = HitHist
Integral/LowerBound = 0
Integral/UpperBound = 1e10
Integral/Hide = false
IntegralHistory/ID = 64
IntegralHistory/HistName = Integral
IntegralHistory/Size = 1200
IntegralHistory/Hide = false


; when the integral is within a certain range whe hit a crystal
[PostProcessor]
IsHit/ID = 9
IsHit/HistName = Integral
IsHit/LowerLimit = 3000
IsHit/UpperLimit = 1e10
IsHit/Hide = false

; average the IsHit state and make a history of it
[PostProcessor]
HitAverage/ID = 61
HitAverage/HistName = IsHit
HitAverage/NbrOfAverages = 10
HitAverage/Hide = false
HitHistory/ID = 64
HitHistory/HistName = HitAverage
HitHistory/Size = 1200
HitHistory/Hide = false



;write chosen output to special hdf5 file to be used with crystfel
[PostProcessor]
dump/ID = 1002
dump/HistName = PnCCDRot
dump/ConditionName = IsHit
