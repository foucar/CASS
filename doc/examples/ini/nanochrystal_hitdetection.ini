;
; this example shows how to detect whether a pnCCD frame contains a nanochrystal
; hit. As input it uses the tcp input.
;

; general setup

[TCPInput]
Server = 192.168.0.2
Port = 9090
DataType = "shm"

;disable the pre analyzers as their functionality is ported to the new framework
[PreAnalyzer]
useCommercialCCDAnalyzer = false
usepnCCDAnalyzer = false

;setup the pnCCD

;;---------------------The Filter -------------------------------------------
[PixelDetectors]
FilterPnCCD/Detector = 0                       ; 0: Front pnCCD detector

;FilterPnCCD/FrameProcessorType = "none"        ; none: Just use the raw image

FilterPnCCD/FrameProcessorType = "hll"         ; hll: HLL type processing
;FilterPnCCD/HLLProcessing/CommonModeCalculationType = "none"
FilterPnCCD/HLLProcessing/CommonModeCalculationType = "simpleMean"
;FilterPnCCD/HLLProcessing/CommonModeCalculationType = "mean"
;FilterPnCCD/HLLProcessing/CommonModeCalculationType = "median"
FilterPnCCD/HLLProcessing/CommonModeCorrection/Width = 128
FilterPnCCD/HLLProcessing/CommonModeCorrection/Multiplier = 4
FilterPnCCD/HLLProcessing/SimpleMeanCommonMode/MinNbrPixels = 8

FilterPnCCD/PixelFinderType = "aboveNoise"     ; uses noise map to identify pixels
FilterPnCCD/AboveNoiseFinder/Multiplier = 4

FilterPnCCD/CoalescingFunctionType = "simple"  ; simple coalscing of pixels
FilterPnCCD/SimpleCoalescing/MaxPixelListSize = 10000 ; if there are more than this amount of pixels in the frame skip the coalscing
FilterPnCCD/SimpleCoalescing/MipThreshold = 1e6       ; if one pixel has a value higher than this than the hit is regarded as "ionizing particle" and skipped
FilterPnCCD/SimpleCoalescing/MaxRecursionDepth = 7    ; how deep will the recursive algorithm go

FilterPnCCD/CorrectionMaps/NoisyPixelThreshold = 2.5  ; all pixels which noises are bigger than this value will be added to the mask

FilterPnCCD/CorrectionMaps/MapCreatorType = "online"  ; fast calculation with fixed amount of events taken to create the correction maps
FilterPnCCD/CorrectionMaps/FixedOnlineCreator/NbrFrames = 200
;FilterPnCCD/CorrectionMaps/FixedOnlineCreator/StartInstantly = true
FilterPnCCD/CorrectionMaps/FixedOnlineCreator/WriteMaps = true

;FilterPnCCD/CorrectionMaps/Mask/size = 0
;FilterPnCCD/CorrectionMaps/Mask/1/MaskElementType = "ellipse"
;FilterPnCCD/CorrectionMaps/Mask/1/OuterCenterX = 500
;FilterPnCCD/CorrectionMaps/Mask/1/OuterCenterY = 500
;FilterPnCCD/CorrectionMaps/Mask/1/OuterSemiAxisX = 50
;FilterPnCCD/CorrectionMaps/Mask/1/OuterSemiAxisY = 10
;FilterPnCCD/CorrectionMaps/Mask/1/InnerCenterX = 500
;FilterPnCCD/CorrectionMaps/Mask/1/InnerCenterY = 500
;FilterPnCCD/CorrectionMaps/Mask/1/InnerSemiAxisX = 50
;FilterPnCCD/CorrectionMaps/Mask/1/InnerSemiAxisY = 10


;; ----------------- The image ------------------------------------------------
[PixelDetectors]
PnCCD/Detector = 0                       ; 0: Front pnCCD detector

PnCCD/FrameProcessorType = "hll"         ; hll: HLL type processing
;PnCCD/HLLProcessing/CommonModeCalculationType = "none"
PnCCD/HLLProcessing/CommonModeCalculationType = "simpleMean"
PnCCD/HLLProcessing/CommonModeCorrection/Width = 128
PnCCD/HLLProcessing/CommonModeCorrection/Multiplier = 4
PnCCD/HLLProcessing/SimpleMeanCommonMode/MinNbrPixels = 8



;---- postprocessors----

; the correction maps
[PostProcessor]
NoiseMap/ID = 107
NoiseMap/Detector = PnCCD
NoiseMap/MapType = noise

[PostProcessor]
OffsetMap/ID = 107
OffsetMap/Detector = PnCCD
OffsetMap/MapType = offset

[PostProcessor]
CorrMap/ID = 107
CorrMap/Detector = PnCCD
CorrMap/MapType = correction


; the final images
[PostProcessor]
[PostProcessor]
PnCCD/ID = 105
PnCCD/Detector = PnCCD
PnCCD/Condition = IsHit
PnCCDRot/ID = 55
PnCCDRot/HistName = PnCCD
PnCCDRot/Operation = 90DegCCW
PnCCDRot/Condition = IsHit



; the image to filter on
[PostProcessor]
FilterPnCCD/ID = 105
FilterPnCCD/Detector = FilterPnCCD


; histogram of all pixels
[PostProcessor]
FrontHist/ID = 106
FrontHist/Detector = FilterPnCCD
FrontHist/XNbrBins = 1000
FrontHist/XLow = 0
FrontHist/XUp = 16400
FrontHist/XTitle = pixel values [adu]

; histogram of non coalesced "photon" pixels
[PostProcessor]
FrontPixelHist/ID = 147
FrontPixelHist/Detector = FilterPnCCD
FrontPixelHist/XNbrBins = 1000
FrontPixelHist/XLow = 0
FrontPixelHist/XUp = 16400
FrontPixelHist/XTitle = pixel values [adu]

; image of non coalesced "photon" pixels as image (will add the pixel value
; at the position where the pixel was found
[PostProcessor]
FrontPixelImage/ID = 148
FrontPixelImage/Detector = FilterPnCCD
FrontPixelImage/PixelvalueAsWeight = true
FrontPixelImage/SpectralLowerLimit = 0
FrontPixelImage/SpectralUpperLimit = 16400
FrontPixelImage/XNbrBins = 256
FrontPixelImage/XLow = 0
FrontPixelImage/XUp = 1024
FrontPixelImage/XTitle = columns
FrontPixelImage/YNbrBins = 256
FrontPixelImage/YLow = 0
FrontPixelImage/YUp = 1024
FrontPixelImage/YTitle = rows

; image of non coalesced "photon" pixels as histogram (will add just a 1
; at the position where the pixel was found
[PostProcessor]
FrontPixelImageHist/ID = 148
FrontPixelImageHist/Detector = FilterPnCCD
FrontPixelImageHist/PixelvalueAsWeight = false
FrontPixelImageHist/SpectralLowerLimit = 0
FrontPixelImageHist/SpectralUpperLimit = 16400
FrontPixelImageHist/XNbrBins = 256
FrontPixelImageHist/XLow = 0
FrontPixelImageHist/XUp = 1024
FrontPixelImageHist/XTitle = columns
FrontPixelImageHist/YNbrBins = 256
FrontPixelImageHist/YLow = 0
FrontPixelImageHist/YUp = 1024
FrontPixelImageHist/YTitle = rows

[PostProcessor] ; the number of non coalesced "photon" pixels found
FrontNbrPixels/ID = 149
FrontNbrPixels/Detector = FilterPnCCD



[PostProcessor] ; histogram of the splitlevel of coalesced "photon" (hit)
FrontHitSplitLvl/ID = 146
FrontHitSplitLvl/Detector = FilterPnCCD
FrontHitSplitLvl/XNbrBins = 1000
FrontHitSplitLvl/XLow = 0
FrontHitSplitLvl/XUp = 16400
FrontHitSplitLvl/XTitle = pixel values [adu]

[PostProcessor] ; histogram of coalesced "photon" pixels (hits)
FrontHitHist/ID = 143
FrontHitHist/Detector = FilterPnCCD
FrontHitHist/SplitLevelLowerLimit = 0
FrontHitHist/SplitLevelUpperLimit = 10
FrontHitHist/XNbrBins = 1000
FrontHitHist/XLow = 0
FrontHitHist/XUp = 16400
FrontHitHist/XTitle = pixel values [adu]

; image of hits as image (will add the pixel value at the position 
; where the hit is)
[PostProcessor]
FrontHitImage/ID = 144
FrontHitImage/Detector = FilterPnCCD
FrontHitImage/PixelvalueAsWeight = true
FrontHitImage/SpectralLowerLimit = 0
FrontHitImage/SpectralUpperLimit = 16400
FrontHitImage/SplitLevelLowerLimit = 0
FrontHitImage/SplitLevelUpperLimit = 10
FrontHitImage/XNbrBins = 256
FrontHitImage/XLow = 0
FrontHitImage/XUp = 1024
FrontHitImage/XTitle = columns
FrontHitImage/YNbrBins = 256
FrontHitImage/YLow = 0
FrontHitImage/YUp = 1024
FrontHitImage/YTitle = rows

; image of hits as histogram (will increment the position where the hit is by 1)
[PostProcessor]
FrontHitImageHist/ID = 144
FrontHitImageHist/Detector = FilterPnCCD
FrontHitImageHist/PixelvalueAsWeight = false
FrontHitImageHist/SpectralLowerLimit = 0
FrontHitImageHist/SpectralUpperLimit = 16400
FrontHitImageHist/SplitLevelLowerLimit = 0
FrontHitImageHist/SplitLevelUpperLimit = 10
FrontHitImageHist/XNbrBins = 256
FrontHitImageHist/XLow = 0
FrontHitImageHist/XUp = 1024
FrontHitImageHist/XTitle = columns
FrontHitImageHist/YNbrBins = 256
FrontHitImageHist/YLow = 0
FrontHitImageHist/YUp = 1024
FrontHitImageHist/YTitle = rows

[PostProcessor] ; the number of coalesced "photon" pixels (hits) found
FrontNbrHits/ID = 145
FrontNbrHits/Detector = FrontPnCCD


;write chosen output to root file (needs option cernroot enabled)
[;PostProcessor]
dump/ID = 1000
dump/Condition = IsHit
