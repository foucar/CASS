#ifndef PDS_EPIX_DDL_H
#define PDS_EPIX_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstddef>
#include <cstring>
#include "pdsdata/xtc/TypeId.hh"
//#include "ndarray/ndarray.h"
//#include "pdsdata/psddl/genericpgp.ddl.h"
namespace Pds {
namespace Epix {

/** @class AsicConfigV1


*/

#pragma pack(push,4)

class AsicConfigV1 {
public:
//  AsicConfigV1(uint8_t arg__monostPulser, uint8_t arg__dummyTest, uint8_t arg__dummyMask, uint16_t arg__pulser, uint8_t arg__pbit, uint8_t arg__atest, uint8_t arg__test, uint8_t arg__sabTest, uint8_t arg__hrTest, uint8_t arg__digMon1, uint8_t arg__digMon2, uint8_t arg__pulserDac, uint8_t arg__Dm1En, uint8_t arg__Dm2En, uint8_t arg__slvdSBit, uint8_t arg__VRefDac, uint8_t arg__TpsTComp, uint8_t arg__TpsMux, uint8_t arg__RoMonost, uint8_t arg__TpsGr, uint8_t arg__S2dGr, uint8_t arg__PpOcbS2d, uint8_t arg__Ocb, uint8_t arg__Monost, uint8_t arg__FastppEnable, uint8_t arg__Preamp, uint8_t arg__PixelCb, uint8_t arg__S2dTComp, uint8_t arg__FilterDac, uint8_t arg__TC, uint8_t arg__S2d, uint8_t arg__S2dDacBias, uint8_t arg__TpsTcDac, uint8_t arg__TpsDac, uint8_t arg__S2dTcDac, uint8_t arg__S2dDac, uint8_t arg__TestBe, uint8_t arg__IsEn, uint8_t arg__DelExec, uint8_t arg__DelCckReg, uint16_t arg__RowStartAddr, uint16_t arg__RowStopAddr, uint8_t arg__ColStartAddr, uint8_t arg__ColStopAddr, uint16_t arg__chipID);
//  AsicConfigV1() {}
//  AsicConfigV1(const AsicConfigV1& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//  }
//  AsicConfigV1& operator=(const AsicConfigV1& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//    return *this;
//  }
  uint8_t monostPulser() const { return uint8_t(this->_reg1 & 0x7); }
  uint8_t dummyTest() const { return uint8_t(this->_reg2 & 0x1); }
  uint8_t dummyMask() const { return uint8_t((this->_reg2>>1) & 0x1); }
  uint16_t pulser() const { return uint16_t(this->_reg3 & 0x3ff); }
  uint8_t pbit() const { return uint8_t((this->_reg3>>10) & 0x1); }
  uint8_t atest() const { return uint8_t((this->_reg3>>11) & 0x1); }
  uint8_t test() const { return uint8_t((this->_reg3>>12) & 0x1); }
  uint8_t sabTest() const { return uint8_t((this->_reg3>>13) & 0x1); }
  uint8_t hrTest() const { return uint8_t((this->_reg3>>14) & 0x1); }
  uint8_t digMon1() const { return uint8_t(this->_reg4 & 0xf); }
  uint8_t digMon2() const { return uint8_t((this->_reg4>>4) & 0xf); }
  uint8_t pulserDac() const { return uint8_t(this->_reg5 & 0x7); }
  uint8_t Dm1En() const { return uint8_t(this->_reg6 & 0x1); }
  uint8_t Dm2En() const { return uint8_t((this->_reg6>>1) & 0x1); }
  uint8_t slvdSBit() const { return uint8_t((this->_reg6>>4) & 0x1); }
  uint8_t VRefDac() const { return uint8_t(this->_reg7 & 0x3f); }
  uint8_t TpsTComp() const { return uint8_t(this->_reg8 & 0x1); }
  uint8_t TpsMux() const { return uint8_t((this->_reg8>>1) & 0xf); }
  uint8_t RoMonost() const { return uint8_t((this->_reg8>>5) & 0x7); }
  uint8_t TpsGr() const { return uint8_t(this->_reg9 & 0xf); }
  uint8_t S2dGr() const { return uint8_t((this->_reg9>>4) & 0xf); }
  uint8_t PpOcbS2d() const { return uint8_t(this->_reg10 & 0x1); }
  uint8_t Ocb() const { return uint8_t((this->_reg10>>1) & 0x7); }
  uint8_t Monost() const { return uint8_t((this->_reg10>>4) & 0x7); }
  uint8_t FastppEnable() const { return uint8_t((this->_reg10>>7) & 0x1); }
  uint8_t Preamp() const { return uint8_t(this->_reg11 & 0x7); }
  uint8_t PixelCb() const { return uint8_t((this->_reg11>>4) & 0x7); }
  uint8_t S2dTComp() const { return uint8_t(this->_reg12 & 0x1); }
  uint8_t FilterDac() const { return uint8_t((this->_reg12>>1) & 0x3f); }
  uint8_t TC() const { return uint8_t(this->_reg13 & 0x3); }
  uint8_t S2d() const { return uint8_t((this->_reg13>>2) & 0x7); }
  uint8_t S2dDacBias() const { return uint8_t((this->_reg13>>5) & 0x7); }
  uint8_t TpsTcDac() const { return uint8_t(this->_reg14 & 0x3); }
  uint8_t TpsDac() const { return uint8_t((this->_reg14>>2) & 0x3f); }
  uint8_t S2dTcDac() const { return uint8_t(this->_reg15 & 0x3); }
  uint8_t S2dDac() const { return uint8_t((this->_reg15>>2) & 0x3f); }
  uint8_t TestBe() const { return uint8_t(this->_reg16 & 0x1); }
  uint8_t IsEn() const { return uint8_t((this->_reg16>>1) & 0x1); }
  uint8_t DelExec() const { return uint8_t((this->_reg16>>2) & 0x1); }
  uint8_t DelCckReg() const { return uint8_t((this->_reg16>>3) & 0x1); }
  uint16_t RowStartAddr() const { return uint16_t(this->_reg17 & 0x1ff); }
  uint16_t RowStopAddr() const { return uint16_t(this->_reg18 & 0x1ff); }
  uint8_t ColStartAddr() const { return uint8_t(this->_reg19 & 0x7f); }
  uint8_t ColStopAddr() const { return uint8_t(this->_reg20 & 0x7f); }
  uint16_t chipID() const { return uint16_t(this->_reg21 & 0xffff); }
  static uint32_t _sizeof() { return 84; }
private:
  uint32_t	_reg1;
  uint32_t	_reg2;
  uint32_t	_reg3;
  uint32_t	_reg4;
  uint32_t	_reg5;
  uint32_t	_reg6;
  uint32_t	_reg7;
  uint32_t	_reg8;
  uint32_t	_reg9;
  uint32_t	_reg10;
  uint32_t	_reg11;
  uint32_t	_reg12;
  uint32_t	_reg13;
  uint32_t	_reg14;
  uint32_t	_reg15;
  uint32_t	_reg16;
  uint32_t	_reg17;
  uint32_t	_reg18;
  uint32_t	_reg19;
  uint32_t	_reg20;
  uint32_t	_reg21;
};
#pragma pack(pop)

/** @class ConfigV1


*/

#pragma pack(push,4)

class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_EpixConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
//  ConfigV1(uint32_t arg__version, uint32_t arg__runTrigDelay, uint32_t arg__daqTrigDelay, uint32_t arg__dacSetting, uint8_t arg__asicGR, uint8_t arg__asicAcq, uint8_t arg__asicR0, uint8_t arg__asicPpmat, uint8_t arg__asicPpbe, uint8_t arg__asicRoClk, uint8_t arg__asicGRControl, uint8_t arg__asicAcqControl, uint8_t arg__asicR0Control, uint8_t arg__asicPpmatControl, uint8_t arg__asicPpbeControl, uint8_t arg__asicR0ClkControl, uint8_t arg__prepulseR0En, uint32_t arg__adcStreamMode, uint8_t arg__testPatternEnable, uint32_t arg__acqToAsicR0Delay, uint32_t arg__asicR0ToAsicAcq, uint32_t arg__asicAcqWidth, uint32_t arg__asicAcqLToPPmatL, uint32_t arg__asicRoClkHalfT, uint32_t arg__adcReadsPerPixel, uint32_t arg__adcClkHalfT, uint32_t arg__asicR0Width, uint32_t arg__adcPipelineDelay, uint32_t arg__prepulseR0Width, uint32_t arg__prepulseR0Delay, uint32_t arg__digitalCardId0, uint32_t arg__digitalCardId1, uint32_t arg__analogCardId0, uint32_t arg__analogCardId1, uint32_t arg__lastRowExclusions, uint32_t arg__numberOfAsicsPerRow, uint32_t arg__numberOfAsicsPerColumn, uint32_t arg__numberOfRowsPerAsic, uint32_t arg__numberOfPixelsPerAsicRow, uint32_t arg__baseClockFrequency, uint32_t arg__asicMask, const Epix::AsicConfigV1* arg__asics, const uint32_t* arg__asicPixelTestArray, const uint32_t* arg__asicPixelMaskArray);
//  ConfigV1(uint32_t numberOfAsicsPerRow, uint32_t numberOfAsicsPerColumn, uint32_t numberOfRowsPerAsic, uint32_t numberOfPixelsPerAsicRow)
//    : _numberOfAsicsPerRow(numberOfAsicsPerRow), _numberOfAsicsPerColumn(numberOfAsicsPerColumn), _numberOfRowsPerAsic(numberOfRowsPerAsic), _numberOfPixelsPerAsicRow(numberOfPixelsPerAsicRow)
//  {
//  }
//  ConfigV1() {}
//  ConfigV1(const ConfigV1& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//  }
//  ConfigV1& operator=(const ConfigV1& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//    return *this;
//  }
  uint32_t version() const { return _version; }
  uint32_t runTrigDelay() const { return _runTrigDelay; }
  uint32_t daqTrigDelay() const { return _daqTrigDelay; }
  uint32_t dacSetting() const { return _dacSetting; }
  uint8_t asicGR() const { return uint8_t(this->_asicPins & 0x1); }
  uint8_t asicAcq() const { return uint8_t((this->_asicPins>>1) & 0x1); }
  uint8_t asicR0() const { return uint8_t((this->_asicPins>>2) & 0x1); }
  uint8_t asicPpmat() const { return uint8_t((this->_asicPins>>3) & 0x1); }
  uint8_t asicPpbe() const { return uint8_t((this->_asicPins>>4) & 0x1); }
  uint8_t asicRoClk() const { return uint8_t((this->_asicPins>>5) & 0x1); }
  uint8_t asicGRControl() const { return uint8_t(this->_asicControls & 0x1); }
  uint8_t asicAcqControl() const { return uint8_t((this->_asicControls>>1) & 0x1); }
  uint8_t asicR0Control() const { return uint8_t((this->_asicControls>>2) & 0x1); }
  uint8_t asicPpmatControl() const { return uint8_t((this->_asicControls>>3) & 0x1); }
  uint8_t asicPpbeControl() const { return uint8_t((this->_asicControls>>4) & 0x1); }
  uint8_t asicR0ClkControl() const { return uint8_t((this->_asicControls>>5) & 0x1); }
  uint8_t prepulseR0En() const { return uint8_t((this->_asicControls>>6) & 0x1); }
  uint32_t adcStreamMode() const { return uint32_t((this->_asicControls>>7) & 0x1); }
  uint8_t testPatternEnable() const { return uint8_t((this->_asicControls>>8) & 0x1); }
  uint32_t acqToAsicR0Delay() const { return _acqToAsicR0Delay; }
  uint32_t asicR0ToAsicAcq() const { return _asicR0ToAsicAcq; }
  uint32_t asicAcqWidth() const { return _asicAcqWidth; }
  uint32_t asicAcqLToPPmatL() const { return _asicAcqLToPPmatL; }
  uint32_t asicRoClkHalfT() const { return _asicRoClkHalfT; }
  uint32_t adcReadsPerPixel() const { return _adcReadsPerPixel; }
  uint32_t adcClkHalfT() const { return _adcClkHalfT; }
  uint32_t asicR0Width() const { return _asicR0Width; }
  uint32_t adcPipelineDelay() const { return _adcPipelineDelay; }
  uint32_t prepulseR0Width() const { return _prepulseR0Width; }
  uint32_t prepulseR0Delay() const { return _prepulseR0Delay; }
  uint32_t digitalCardId0() const { return _digitalCardId0; }
  uint32_t digitalCardId1() const { return _digitalCardId1; }
  uint32_t analogCardId0() const { return _analogCardId0; }
  uint32_t analogCardId1() const { return _analogCardId1; }
  uint32_t lastRowExclusions() const { return _lastRowExclusions; }
  uint32_t numberOfAsicsPerRow() const { return _numberOfAsicsPerRow; }
  uint32_t numberOfAsicsPerColumn() const { return _numberOfAsicsPerColumn; }
  /** generally 2 x 2 */
  uint32_t numberOfRowsPerAsic() const { return _numberOfRowsPerAsic; }
  /** for epix100  352 */
  uint32_t numberOfPixelsPerAsicRow() const { return _numberOfPixelsPerAsicRow; }
  /** for epix100 96*4 */
  uint32_t baseClockFrequency() const { return _baseClockFrequency; }
  uint32_t asicMask() const { return _asicMask; }
  const Epix::AsicConfigV1& asics(uint32_t i0) const { ptrdiff_t offset=112;
  const Epix::AsicConfigV1* memptr = (const Epix::AsicConfigV1*)(((const char*)this)+offset);
  size_t memsize = memptr->_sizeof();
  return *(const Epix::AsicConfigV1*)((const char*)memptr + (i0)*memsize); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint32_t, 3> asicPixelTestArray(const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=112+(84*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
//    const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(),  this->numberOfRowsPerAsic(),  (this->numberOfPixelsPerAsicRow()+31)/32);
//  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint32_t, 3> asicPixelTestArray() const { ptrdiff_t offset=112+(84*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
//  const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
//  return make_ndarray(data, this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(),  this->numberOfRowsPerAsic(),  (this->numberOfPixelsPerAsicRow()+31)/32); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint32_t, 3> asicPixelMaskArray(const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=(112+(84*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(4*(((this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())*( this->numberOfRowsPerAsic()))*( (this->numberOfPixelsPerAsicRow()+31)/32)));
//    const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(),  this->numberOfRowsPerAsic(),  (this->numberOfPixelsPerAsicRow()+31)/32);
//  }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint32_t, 3> asicPixelMaskArray() const { ptrdiff_t offset=(112+(84*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(4*(((this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())*( this->numberOfRowsPerAsic()))*( (this->numberOfPixelsPerAsicRow()+31)/32)));
//  const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
//  return make_ndarray(data, this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(),  this->numberOfRowsPerAsic(),  (this->numberOfPixelsPerAsicRow()+31)/32); }
  /** Number of rows in a readout unit */
  uint32_t numberOfRows() const { return this->numberOfAsicsPerColumn()*this->numberOfRowsPerAsic() - this->lastRowExclusions(); }
  /** Number of columns in a readout unit */
  uint32_t numberOfColumns() const { return  this->numberOfAsicsPerRow()*this->numberOfPixelsPerAsicRow(); }
  /** Number of columns in a readout unit */
  uint32_t numberOfAsics() const { return  this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(); }
  uint32_t _sizeof() const { return ((((((112+(Epix::AsicConfigV1::_sizeof()*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(4*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())*( this->numberOfRowsPerAsic())*( (this->numberOfPixelsPerAsicRow()+31)/32)))+(4*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())*( this->numberOfRowsPerAsic())*( (this->numberOfPixelsPerAsicRow()+31)/32)))+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by asics() method. */
  std::vector<int> asics_shape() const;
private:
  uint32_t	_version;
  uint32_t	_runTrigDelay;
  uint32_t	_daqTrigDelay;
  uint32_t	_dacSetting;
  uint32_t	_asicPins;
  uint32_t	_asicControls;
  uint32_t	_acqToAsicR0Delay;
  uint32_t	_asicR0ToAsicAcq;
  uint32_t	_asicAcqWidth;
  uint32_t	_asicAcqLToPPmatL;
  uint32_t	_asicRoClkHalfT;
  uint32_t	_adcReadsPerPixel;
  uint32_t	_adcClkHalfT;
  uint32_t	_asicR0Width;
  uint32_t	_adcPipelineDelay;
  uint32_t	_prepulseR0Width;
  uint32_t	_prepulseR0Delay;
  uint32_t	_digitalCardId0;
  uint32_t	_digitalCardId1;
  uint32_t	_analogCardId0;
  uint32_t	_analogCardId1;
  uint32_t	_lastRowExclusions;
  uint32_t	_numberOfAsicsPerRow;
  uint32_t	_numberOfAsicsPerColumn;
  uint32_t	_numberOfRowsPerAsic;	/**< generally 2 x 2 */
  uint32_t	_numberOfPixelsPerAsicRow;	/**< for epix100  352 */
  uint32_t	_baseClockFrequency;	/**< for epix100 96*4 */
  uint32_t	_asicMask;
  //Epix::AsicConfigV1	_asics[this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()];
  //uint32_t	_asicPixelTestArray[this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()][ this->numberOfRowsPerAsic()][ (this->numberOfPixelsPerAsicRow()+31)/32];
  //uint32_t	_asicPixelMaskArray[this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()][ this->numberOfRowsPerAsic()][ (this->numberOfPixelsPerAsicRow()+31)/32];
};
#pragma pack(pop)

/** @class Asic10kConfigV1


*/

#pragma pack(push,4)

class Asic10kConfigV1 {
public:
//  Asic10kConfigV1(uint8_t arg__CompTH_DAC, uint8_t arg__CompEn_0, uint8_t arg__PulserSync, uint8_t arg__dummyTest, uint8_t arg__dummyMask, uint8_t arg__dummyG, uint8_t arg__dummyGA, uint16_t arg__dummyUpper12bits, uint16_t arg__pulser, uint8_t arg__pbit, uint8_t arg__atest, uint8_t arg__test, uint8_t arg__sabTest, uint8_t arg__hrTest, uint8_t arg__PulserR, uint8_t arg__digMon1, uint8_t arg__digMon2, uint8_t arg__pulserDac, uint8_t arg__monostPulser, uint8_t arg__CompEn_1, uint8_t arg__CompEn_2, uint8_t arg__Dm1En, uint8_t arg__Dm2En, uint8_t arg__emph_bd, uint8_t arg__emph_bc, uint8_t arg__VRefDac, uint8_t arg__VrefLow, uint8_t arg__TpsTComp, uint8_t arg__TpsMux, uint8_t arg__RoMonost, uint8_t arg__TpsGr, uint8_t arg__S2dGr, uint8_t arg__PpOcbS2d, uint8_t arg__Ocb, uint8_t arg__Monost, uint8_t arg__FastppEnable, uint8_t arg__Preamp, uint8_t arg__PixelCb, uint8_t arg__Vld1_b, uint8_t arg__S2dTComp, uint8_t arg__FilterDac, uint8_t arg__testVDTransmitter, uint8_t arg__TC, uint8_t arg__S2d, uint8_t arg__S2dDacBias, uint8_t arg__TpsTcDac, uint8_t arg__TpsDac, uint8_t arg__S2dTcDac, uint8_t arg__S2dDac, uint8_t arg__TestBe, uint8_t arg__IsEn, uint8_t arg__DelExec, uint8_t arg__DelCckReg, uint8_t arg__RO_rst_en, uint8_t arg__slvdSBit, uint8_t arg__FELmode, uint8_t arg__CompEnOn, uint16_t arg__RowStartAddr, uint16_t arg__RowStopAddr, uint8_t arg__ColStartAddr, uint8_t arg__ColStopAddr, uint16_t arg__chipID);
//  Asic10kConfigV1() {}
//  Asic10kConfigV1(const Asic10kConfigV1& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//  }
//  Asic10kConfigV1& operator=(const Asic10kConfigV1& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//    return *this;
//  }
  uint8_t CompTH_DAC() const { return uint8_t(this->_reg1 & 0x3f); }
  uint8_t CompEn_0() const { return uint8_t((this->_reg1>>6) & 0x1); }
  uint8_t PulserSync() const { return uint8_t((this->_reg1>>7) & 0x1); }
  uint8_t dummyTest() const { return uint8_t(this->_reg2 & 0x1); }
  uint8_t dummyMask() const { return uint8_t((this->_reg2>>1) & 0x1); }
  uint8_t dummyG() const { return uint8_t((this->_reg2>>2) & 0x1); }
  uint8_t dummyGA() const { return uint8_t((this->_reg2>>3) & 0x1); }
  uint16_t dummyUpper12bits() const { return uint16_t((this->_reg2>>4) & 0xfff); }
  uint16_t pulser() const { return uint16_t(this->_reg3 & 0x3ff); }
  uint8_t pbit() const { return uint8_t((this->_reg3>>10) & 0x1); }
  uint8_t atest() const { return uint8_t((this->_reg3>>11) & 0x1); }
  uint8_t test() const { return uint8_t((this->_reg3>>12) & 0x1); }
  uint8_t sabTest() const { return uint8_t((this->_reg3>>13) & 0x1); }
  uint8_t hrTest() const { return uint8_t((this->_reg3>>14) & 0x1); }
  uint8_t pulserR() const { return uint8_t((this->_reg3>>15) & 0x1); }
  uint8_t digMon1() const { return uint8_t(this->_reg4 & 0xf); }
  uint8_t digMon2() const { return uint8_t((this->_reg4>>4) & 0xf); }
  uint8_t pulserDac() const { return uint8_t(this->_reg5 & 0x7); }
  uint8_t monostPulser() const { return uint8_t((this->_reg5>>3) & 0x7); }
  uint8_t CompEn_1() const { return uint8_t((this->_reg5>>6) & 0x1); }
  uint8_t CompEn_2() const { return uint8_t((this->_reg5>>7) & 0x1); }
  uint8_t Dm1En() const { return uint8_t(this->_reg6 & 0x1); }
  uint8_t Dm2En() const { return uint8_t((this->_reg6>>1) & 0x1); }
  uint8_t emph_bd() const { return uint8_t((this->_reg6>>2) & 0x7); }
  uint8_t emph_bc() const { return uint8_t((this->_reg6>>5) & 0x7); }
  uint8_t VRefDac() const { return uint8_t(this->_reg7 & 0x3f); }
  uint8_t vrefLow() const { return uint8_t((this->_reg7>>6) & 0x3); }
  uint8_t TpsTComp() const { return uint8_t(this->_reg8 & 0x1); }
  uint8_t TpsMux() const { return uint8_t((this->_reg8>>1) & 0xf); }
  uint8_t RoMonost() const { return uint8_t((this->_reg8>>5) & 0x7); }
  uint8_t TpsGr() const { return uint8_t(this->_reg9 & 0xf); }
  uint8_t S2dGr() const { return uint8_t((this->_reg9>>4) & 0xf); }
  uint8_t PpOcbS2d() const { return uint8_t(this->_reg10 & 0x1); }
  uint8_t Ocb() const { return uint8_t((this->_reg10>>1) & 0x7); }
  uint8_t Monost() const { return uint8_t((this->_reg10>>4) & 0x7); }
  uint8_t FastppEnable() const { return uint8_t((this->_reg10>>7) & 0x1); }
  uint8_t Preamp() const { return uint8_t(this->_reg11 & 0x7); }
  uint8_t PixelCb() const { return uint8_t((this->_reg11>>3) & 0x7); }
  uint8_t Vld1_b() const { return uint8_t((this->_reg11>>6) & 0x3); }
  uint8_t S2dTComp() const { return uint8_t(this->_reg12 & 0x1); }
  uint8_t FilterDac() const { return uint8_t((this->_reg12>>1) & 0x3f); }
  uint8_t testVDTransmitter() const { return uint8_t((this->_reg12>>7) & 0x1); }
  uint8_t TC() const { return uint8_t(this->_reg13 & 0x3); }
  uint8_t S2d() const { return uint8_t((this->_reg13>>2) & 0x7); }
  uint8_t S2dDacBias() const { return uint8_t((this->_reg13>>5) & 0x7); }
  uint8_t TpsTcDac() const { return uint8_t(this->_reg14 & 0x3); }
  uint8_t TpsDac() const { return uint8_t((this->_reg14>>2) & 0x3f); }
  uint8_t S2dTcDac() const { return uint8_t(this->_reg15 & 0x3); }
  uint8_t S2dDac() const { return uint8_t((this->_reg15>>2) & 0x3f); }
  uint8_t TestBe() const { return uint8_t(this->_reg16 & 0x1); }
  uint8_t IsEn() const { return uint8_t((this->_reg16>>1) & 0x1); }
  uint8_t DelExec() const { return uint8_t((this->_reg16>>2) & 0x1); }
  uint8_t DelCckReg() const { return uint8_t((this->_reg16>>3) & 0x1); }
  uint8_t RO_rst_en() const { return uint8_t((this->_reg16>>4) & 0x1); }
  uint8_t slvdSBit() const { return uint8_t((this->_reg16>>5) & 0x1); }
  uint8_t FELmode() const { return uint8_t((this->_reg16>>6) & 0x1); }
  uint8_t CompEnOn() const { return uint8_t((this->_reg16>>7) & 0x1); }
  uint16_t RowStartAddr() const { return uint16_t(this->_reg17 & 0x1ff); }
  uint16_t RowStopAddr() const { return uint16_t(this->_reg18 & 0x1ff); }
  uint8_t ColStartAddr() const { return uint8_t(this->_reg19 & 0x7f); }
  uint8_t ColStopAddr() const { return uint8_t(this->_reg20 & 0x7f); }
  uint16_t chipID() const { return uint16_t(this->_reg21 & 0xffff); }
  static uint32_t _sizeof() { return 84; }
private:
  uint32_t	_reg1;
  uint32_t	_reg2;
  uint32_t	_reg3;
  uint32_t	_reg4;
  uint32_t	_reg5;
  uint32_t	_reg6;
  uint32_t	_reg7;
  uint32_t	_reg8;
  uint32_t	_reg9;
  uint32_t	_reg10;
  uint32_t	_reg11;
  uint32_t	_reg12;
  uint32_t	_reg13;
  uint32_t	_reg14;
  uint32_t	_reg15;
  uint32_t	_reg16;
  uint32_t	_reg17;
  uint32_t	_reg18;
  uint32_t	_reg19;
  uint32_t	_reg20;
  uint32_t	_reg21;
};
#pragma pack(pop)

/** @class Config10KV1


*/

#pragma pack(push,4)

class Config10KV1 {
public:
  enum { TypeId = Pds::TypeId::Id_Epix10kConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
//  Config10KV1(uint32_t arg__version, uint32_t arg__runTrigDelay, uint32_t arg__daqTrigDelay, uint32_t arg__dacSetting, uint8_t arg__asicGR, uint8_t arg__asicAcq, uint8_t arg__asicR0, uint8_t arg__asicPpmat, uint8_t arg__asicPpbe, uint8_t arg__asicRoClk, uint8_t arg__asicGRControl, uint8_t arg__asicAcqControl, uint8_t arg__asicR0Control, uint8_t arg__asicPpmatControl, uint8_t arg__asicPpbeControl, uint8_t arg__asicR0ClkControl, uint8_t arg__prepulseR0En, uint32_t arg__adcStreamMode, uint8_t arg__testPatternEnable, uint8_t arg__SyncMode, uint8_t arg__R0Mode, uint32_t arg__DoutPipelineDelay, uint32_t arg__acqToAsicR0Delay, uint32_t arg__asicR0ToAsicAcq, uint32_t arg__asicAcqWidth, uint32_t arg__asicAcqLToPPmatL, uint32_t arg__asicRoClkHalfT, uint32_t arg__adcReadsPerPixel, uint32_t arg__adcClkHalfT, uint32_t arg__asicR0Width, uint32_t arg__adcPipelineDelay, uint16_t arg__SyncWidth, uint16_t arg__SyncDelay, uint32_t arg__prepulseR0Width, uint32_t arg__prepulseR0Delay, uint32_t arg__digitalCardId0, uint32_t arg__digitalCardId1, uint32_t arg__analogCardId0, uint32_t arg__analogCardId1, uint32_t arg__lastRowExclusions, uint32_t arg__numberOfAsicsPerRow, uint32_t arg__numberOfAsicsPerColumn, uint32_t arg__numberOfRowsPerAsic, uint32_t arg__numberOfPixelsPerAsicRow, uint32_t arg__baseClockFrequency, uint32_t arg__asicMask, uint8_t arg__scopeEnable, uint8_t arg__scopeTrigEdge, uint8_t arg__scopeTrigChan, uint8_t arg__scopeArmMode, uint16_t arg__scopeADCThreshold, uint16_t arg__scopeTrigHoldoff, uint16_t arg__scopeTrigOffset, uint16_t arg__scopeTraceLength, uint16_t arg__scopeADCsameplesToSkip, uint8_t arg__scopeChanAwaveformSelect, uint8_t arg__scopeChanBwaveformSelect, const Epix::Asic10kConfigV1* arg__asics, const uint16_t* arg__asicPixelConfigArray);
//  Config10KV1(uint32_t numberOfAsicsPerRow, uint32_t numberOfAsicsPerColumn, uint32_t numberOfRowsPerAsic, uint32_t numberOfPixelsPerAsicRow, uint32_t lastRowExclusions)
//    : _lastRowExclusions(lastRowExclusions), _numberOfAsicsPerRow(numberOfAsicsPerRow), _numberOfAsicsPerColumn(numberOfAsicsPerColumn), _numberOfRowsPerAsic(numberOfRowsPerAsic), _numberOfPixelsPerAsicRow(numberOfPixelsPerAsicRow)
//  {
//  }
//  Config10KV1() {}
//  Config10KV1(const Config10KV1& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//  }
//  Config10KV1& operator=(const Config10KV1& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//    return *this;
//  }
  uint32_t version() const { return _version; }
  uint32_t runTrigDelay() const { return _runTrigDelay; }
  uint32_t daqTrigDelay() const { return _daqTrigDelay; }
  uint32_t dacSetting() const { return _dacSetting; }
  uint8_t asicGR() const { return uint8_t(this->_asicPins & 0x1); }
  uint8_t asicAcq() const { return uint8_t((this->_asicPins>>1) & 0x1); }
  uint8_t asicR0() const { return uint8_t((this->_asicPins>>2) & 0x1); }
  uint8_t asicPpmat() const { return uint8_t((this->_asicPins>>3) & 0x1); }
  uint8_t asicPpbe() const { return uint8_t((this->_asicPins>>4) & 0x1); }
  uint8_t asicRoClk() const { return uint8_t((this->_asicPins>>5) & 0x1); }
  uint8_t asicGRControl() const { return uint8_t(this->_asicControls & 0x1); }
  uint8_t asicAcqControl() const { return uint8_t((this->_asicControls>>1) & 0x1); }
  uint8_t asicR0Control() const { return uint8_t((this->_asicControls>>2) & 0x1); }
  uint8_t asicPpmatControl() const { return uint8_t((this->_asicControls>>3) & 0x1); }
  uint8_t asicPpbeControl() const { return uint8_t((this->_asicControls>>4) & 0x1); }
  uint8_t asicR0ClkControl() const { return uint8_t((this->_asicControls>>5) & 0x1); }
  uint8_t prepulseR0En() const { return uint8_t((this->_asicControls>>6) & 0x1); }
  uint32_t adcStreamMode() const { return uint32_t((this->_asicControls>>7) & 0x1); }
  uint8_t testPatternEnable() const { return uint8_t((this->_asicControls>>8) & 0x1); }
  /** new */
  uint8_t SyncMode() const { return uint8_t((this->_asicControls>>9) & 0x3); }
  /** new */
  uint8_t R0Mode() const { return uint8_t((this->_asicControls>>11) & 0x1); }
  /** new */
  uint32_t DoutPipelineDelay() const { return _DoutPipelineDelay; }
  uint32_t acqToAsicR0Delay() const { return _acqToAsicR0Delay; }
  uint32_t asicR0ToAsicAcq() const { return _asicR0ToAsicAcq; }
  uint32_t asicAcqWidth() const { return _asicAcqWidth; }
  uint32_t asicAcqLToPPmatL() const { return _asicAcqLToPPmatL; }
  uint32_t asicRoClkHalfT() const { return _asicRoClkHalfT; }
  uint32_t adcReadsPerPixel() const { return _adcReadsPerPixel; }
  uint32_t adcClkHalfT() const { return _adcClkHalfT; }
  uint32_t asicR0Width() const { return _asicR0Width; }
  uint32_t adcPipelineDelay() const { return _adcPipelineDelay; }
  /** new */
  uint16_t SyncWidth() const { return uint16_t(this->_Sync & 0xffff); }
  /** new */
  uint16_t SyncDelay() const { return uint16_t((this->_Sync>>16) & 0xffff); }
  uint32_t prepulseR0Width() const { return _prepulseR0Width; }
  uint32_t prepulseR0Delay() const { return _prepulseR0Delay; }
  uint32_t digitalCardId0() const { return _digitalCardId0; }
  uint32_t digitalCardId1() const { return _digitalCardId1; }
  uint32_t analogCardId0() const { return _analogCardId0; }
  uint32_t analogCardId1() const { return _analogCardId1; }
  uint32_t lastRowExclusions() const { return _lastRowExclusions; }
  uint32_t numberOfAsicsPerRow() const { return _numberOfAsicsPerRow; }
  uint32_t numberOfAsicsPerColumn() const { return _numberOfAsicsPerColumn; }
  uint32_t numberOfRowsPerAsic() const { return _numberOfRowsPerAsic; }
  /** for epix10k  176 */
  uint32_t numberOfPixelsPerAsicRow() const { return _numberOfPixelsPerAsicRow; }
  /** for epix10k 48*4 */
  uint32_t baseClockFrequency() const { return _baseClockFrequency; }
  uint32_t asicMask() const { return _asicMask; }
  uint8_t scopeEnable() const { return uint8_t(this->_Scope & 0x1); }
  uint8_t scopeTrigEdge() const { return uint8_t((this->_Scope>>1) & 0x1); }
  uint8_t scopeTrigChan() const { return uint8_t((this->_Scope>>2) & 0xf); }
  uint8_t scopeArmMode() const { return uint8_t((this->_Scope>>6) & 0x3); }
  uint16_t scopeADCThreshold() const { return uint16_t((this->_Scope>>16) & 0xffff); }
  uint16_t scopeTrigHoldoff() const { return uint16_t(this->_ScopeTriggerParms_1 & 0x1fff); }
  uint16_t scopeTrigOffset() const { return uint16_t((this->_ScopeTriggerParms_1>>13) & 0x1fff); }
  uint16_t scopeTraceLength() const { return uint16_t(this->_ScopeTriggerParms_2 & 0x1fff); }
  uint16_t scopeADCsameplesToSkip() const { return uint16_t((this->_ScopeTriggerParms_2>>13) & 0x1fff); }
  uint8_t scopeChanAwaveformSelect() const { return uint8_t(this->_ScopeWaveformSelects & 0x1f); }
  uint8_t scopeChanBwaveformSelect() const { return uint8_t((this->_ScopeWaveformSelects>>5) & 0x1f); }
  const Epix::Asic10kConfigV1& asics(uint32_t i0) const { ptrdiff_t offset=136;
  const Epix::Asic10kConfigV1* memptr = (const Epix::Asic10kConfigV1*)(((const char*)this)+offset);
  size_t memsize = memptr->_sizeof();
  return *(const Epix::Asic10kConfigV1*)((const char*)memptr + (i0)*memsize); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 3> asicPixelConfigArray(const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=136+(84*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(),  this->numberOfRowsPerAsic(),  (this->numberOfPixelsPerAsicRow()));
//  }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 3> asicPixelConfigArray() const { ptrdiff_t offset=136+(84*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(),  this->numberOfRowsPerAsic(),  (this->numberOfPixelsPerAsicRow())); }
  /** Number of rows in a readout unit */
  uint32_t numberOfRows() const { return this->numberOfAsicsPerColumn()*this->numberOfRowsPerAsic() - this->lastRowExclusions(); }
  /** Number of columns in a readout unit */
  uint32_t numberOfColumns() const { return  this->numberOfAsicsPerRow()*this->numberOfPixelsPerAsicRow(); }
  /** Number of columns in a readout unit */
  uint32_t numberOfAsics() const { return  this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(); }
  uint32_t _sizeof() const { return (((((136+(Epix::Asic10kConfigV1::_sizeof()*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())*( this->numberOfRowsPerAsic())*( (this->numberOfPixelsPerAsicRow()))))+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by asics() method. */
  std::vector<int> asics_shape() const;
private:
  uint32_t	_version;
  uint32_t	_runTrigDelay;
  uint32_t	_daqTrigDelay;
  uint32_t	_dacSetting;
  uint32_t	_asicPins;
  uint32_t	_asicControls;
  uint32_t	_DoutPipelineDelay;	/**< new */
  uint32_t	_acqToAsicR0Delay;
  uint32_t	_asicR0ToAsicAcq;
  uint32_t	_asicAcqWidth;
  uint32_t	_asicAcqLToPPmatL;
  uint32_t	_asicRoClkHalfT;
  uint32_t	_adcReadsPerPixel;
  uint32_t	_adcClkHalfT;
  uint32_t	_asicR0Width;
  uint32_t	_adcPipelineDelay;
  uint32_t	_Sync;	/**< new */
  uint32_t	_prepulseR0Width;
  uint32_t	_prepulseR0Delay;
  uint32_t	_digitalCardId0;
  uint32_t	_digitalCardId1;
  uint32_t	_analogCardId0;
  uint32_t	_analogCardId1;
  uint32_t	_lastRowExclusions;
  uint32_t	_numberOfAsicsPerRow;
  uint32_t	_numberOfAsicsPerColumn;
  uint32_t	_numberOfRowsPerAsic;
  uint32_t	_numberOfPixelsPerAsicRow;	/**< for epix10k  176 */
  uint32_t	_baseClockFrequency;	/**< for epix10k 48*4 */
  uint32_t	_asicMask;
  uint32_t	_Scope;
  uint32_t	_ScopeTriggerParms_1;
  uint32_t	_ScopeTriggerParms_2;
  uint32_t	_ScopeWaveformSelects;
  //Epix::Asic10kConfigV1	_asics[this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()];
  //uint16_t	_asicPixelConfigArray[this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()][ this->numberOfRowsPerAsic()][ (this->numberOfPixelsPerAsicRow())];
};
#pragma pack(pop)

/** @class Asic100aConfigV1


*/

#pragma pack(push,4)

class Asic100aConfigV1 {
public:
//  Asic100aConfigV1(uint8_t arg__pulserVsPixelOnDelay, uint8_t arg__pulserSync, uint8_t arg__dummyTest, uint8_t arg__dummyMask, uint16_t arg__testPulserLevel, uint8_t arg__pulserCounterDirection, uint8_t arg__automaticTestModeEnable, uint8_t arg__testMode, uint8_t arg__testModeWithDarkFrame, uint8_t arg__highResolutionModeTest, uint8_t arg__pulserReset, uint8_t arg__digitalMonitorMux1, uint8_t arg__digitalMonitorMux2, uint8_t arg__testPulserCurrent, uint8_t arg__testPointSystemOutputDynamicRange, uint8_t arg__digitalMonitor1Enable, uint8_t arg__digitalMonitor2Enable, uint8_t arg__LVDS_ImpedenceMatchingEnable, uint8_t arg__VRefBaseLineDac, uint8_t arg__extraRowsLowReferenceValue, uint8_t arg__testPointSystemTemperatureCompensationEnable, uint8_t arg__testPointSytemInputSelect, uint8_t arg__programmableReadoutDelay, uint8_t arg__outputDriverOutputDynamicRange0, uint8_t arg__outputDriverOutputDynamicRange1, uint8_t arg__balconyEnable, uint8_t arg__balconyDriverCurrent, uint8_t arg__fastPowerPulsingSpeed, uint8_t arg__fastPowerPulsingEnable, uint8_t arg__preamplifierCurrent, uint8_t arg__pixelOutputBufferCurrent, uint8_t arg__pixelBufferAndPreamplifierDrivingCapabilities, uint8_t arg__outputDriverTemperatureCompensationEnable, uint8_t arg__pixelFilterLevel, uint8_t arg__bandGapReferenceTemperatureCompensationBits, uint8_t arg__outputDriverDrivingCapabilitiesAndStability, uint8_t arg__outputDriverDacReferenceBias, uint8_t arg__testPointSystemTemperatureCompensationGain, uint8_t arg__testPointSystemInputCommonMode, uint8_t arg__outputDriverTemperatureCompensationGain0, uint8_t arg__outputDriverInputCommonMode0, uint8_t arg__testBackEnd, uint8_t arg__interleavedReadOutEnable, uint8_t arg_EXEC_DelayEnable, uint8_t arg__CCK_RegDelayEnable, uint8_t arg__syncPinEnable, uint16_t arg__RowStartAddr, uint16_t arg__RowStopAddr, uint8_t arg__ColumnStartAddr, uint8_t arg__ColumnStopAddr, uint16_t arg__chipID, uint8_t arg__outputDriverOutputDynamicRange2, uint8_t arg__outputDriverOutputDynamicRange3, uint8_t arg__outputDriverTemperatureCompensationGain1, uint8_t arg__outputDriverInputCommonMode1, uint8_t arg__outputDriverTemperatureCompensationGain2, uint8_t arg__outputDriverInputCommonMode2, uint8_t arg__outputDriverTemperatureCompensationGain3, uint8_t arg__outputDriverInputCommonMode3);
//  Asic100aConfigV1() {}
//  Asic100aConfigV1(const Asic100aConfigV1& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//  }
//  Asic100aConfigV1& operator=(const Asic100aConfigV1& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//    return *this;
//  }
  uint8_t pulserVsPixelOnDelay() const { return uint8_t(this->_reg1 & 0x7); }
  uint8_t pulserSync() const { return uint8_t((this->_reg1>>7) & 0x1); }
  uint8_t dummyTest() const { return uint8_t(this->_reg2 & 0x1); }
  uint8_t dummyMask() const { return uint8_t((this->_reg2>>1) & 0x1); }
  uint16_t testPulserLevel() const { return uint16_t(this->_reg3 & 0x3ff); }
  uint8_t pulserCounterDirection() const { return uint8_t((this->_reg3>>10) & 0x1); }
  uint8_t automaticTestModeEnable() const { return uint8_t((this->_reg3>>11) & 0x1); }
  uint8_t testMode() const { return uint8_t((this->_reg3>>12) & 0x1); }
  uint8_t testModeWithDarkFrame() const { return uint8_t((this->_reg3>>13) & 0x1); }
  uint8_t highResolutionModeTest() const { return uint8_t((this->_reg3>>14) & 0x1); }
  uint8_t pulserReset() const { return uint8_t((this->_reg3>>15) & 0x1); }
  uint8_t digitalMonitorMux1() const { return uint8_t(this->_reg4 & 0xf); }
  uint8_t digitalMonitorMux2() const { return uint8_t((this->_reg4>>4) & 0xf); }
  uint8_t testPulserCurrent() const { return uint8_t(this->_reg5 & 0x7); }
  uint8_t testPointSystemOutputDynamicRange() const { return uint8_t((this->_reg5>>4) & 0xf); }
  uint8_t digitalMonitor1Enable() const { return uint8_t(this->_reg6 & 0x1); }
  uint8_t digitalMonitor2Enable() const { return uint8_t((this->_reg6>>1) & 0x1); }
  uint8_t LVDS_ImpedenceMatchingEnable() const { return uint8_t((this->_reg6>>4) & 0x1); }
  uint8_t VRefBaselineDac() const { return uint8_t(this->_reg7 & 0x3f); }
  uint8_t extraRowsLowReferenceValue() const { return uint8_t((this->_reg7>>6) & 0x3); }
  uint8_t testPointSystemTemperatureCompensationEnable() const { return uint8_t(this->_reg8 & 0x1); }
  uint8_t testPointSytemInputSelect() const { return uint8_t((this->_reg8>>1) & 0xf); }
  uint8_t programmableReadoutDelay() const { return uint8_t((this->_reg8>>5) & 0x7); }
  uint8_t outputDriverOutputDynamicRange0() const { return uint8_t(this->_reg9 & 0xf); }
  uint8_t outputDriverOutputDynamicRange1() const { return uint8_t((this->_reg9>>4) & 0xf); }
  uint8_t balconyEnable() const { return uint8_t(this->_reg10 & 0x1); }
  uint8_t balconyDriverCurrent() const { return uint8_t((this->_reg10>>1) & 0x7); }
  uint8_t fastPowerPulsingSpeed() const { return uint8_t((this->_reg10>>4) & 0x7); }
  uint8_t fastPowerPulsingEnable() const { return uint8_t((this->_reg10>>7) & 0x1); }
  uint8_t preamplifierCurrent() const { return uint8_t(this->_reg11 & 0x7); }
  uint8_t pixelOutputBufferCurrent() const { return uint8_t((this->_reg11>>3) & 0x7); }
  uint8_t pixelBufferAndPreamplifierDrivingCapabilities() const { return uint8_t((this->_reg11>>6) & 0x3); }
  uint8_t outputDriverTemperatureCompensationEnable() const { return uint8_t(this->_reg12 & 0x1); }
  uint8_t pixelFilterLevel() const { return uint8_t((this->_reg12>>1) & 0x3f); }
  uint8_t bandGapReferenceTemperatureCompensationBits() const { return uint8_t(this->_reg13 & 0x3); }
  uint8_t outputDriverDrivingCapabilitiesAndStability() const { return uint8_t((this->_reg13>>2) & 0x7); }
  uint8_t outputDriverDacReferenceBias() const { return uint8_t((this->_reg13>>5) & 0x7); }
  uint8_t testPointSystemTemperatureCompensationGain() const { return uint8_t(this->_reg14 & 0x3); }
  uint8_t testPointSystemInputCommonMode() const { return uint8_t((this->_reg14>>2) & 0x3f); }
  uint8_t outputDriverTemperatureCompensationGain0() const { return uint8_t(this->_reg15 & 0x3); }
  uint8_t outputDriverInputCommonMode0() const { return uint8_t((this->_reg15>>2) & 0x3f); }
  uint8_t testBackEnd() const { return uint8_t(this->_reg16 & 0x1); }
  uint8_t interleavedReadOutEnable() const { return uint8_t((this->_reg16>>1) & 0x1); }
  uint8_t EXEC_DelayEnable() const { return uint8_t((this->_reg16>>2) & 0x1); }
  uint8_t CCK_RegDelayEnable() const { return uint8_t((this->_reg16>>3) & 0x1); }
  uint8_t syncPinEnable() const { return uint8_t((this->_reg16>>4) & 0x1); }
  uint16_t RowStartAddr() const { return uint16_t(this->_reg17 & 0x1ff); }
  uint16_t RowStopAddr() const { return uint16_t(this->_reg18 & 0x1ff); }
  uint8_t ColumnStartAddr() const { return uint8_t(this->_reg19 & 0x7f); }
  uint8_t ColumnStopAddr() const { return uint8_t(this->_reg20 & 0x7f); }
  uint16_t chipID() const { return uint16_t(this->_reg21 & 0xffff); }
  uint8_t outputDriverOutputDynamicRange2() const { return uint8_t(this->_reg22 & 0xf); }
  uint8_t outputDriverOutputDynamicRange3() const { return uint8_t((this->_reg22>>4) & 0xf); }
  uint8_t outputDriverTemperatureCompensationGain1() const { return uint8_t(this->_reg23 & 0x3); }
  uint8_t outputDriverInputCommonMode1() const { return uint8_t((this->_reg23>>2) & 0x3f); }
  uint8_t outputDriverTemperatureCompensationGain2() const { return uint8_t(this->_reg24 & 0x3); }
  uint8_t outputDriverInputCommonMode2() const { return uint8_t((this->_reg24>>2) & 0x3f); }
  uint8_t outputDriverTemperatureCompensationGain3() const { return uint8_t(this->_reg25 & 0x3); }
  uint8_t outputDriverInputCommonMode3() const { return uint8_t((this->_reg25>>2) & 0x3f); }
  static uint32_t _sizeof() { return 100; }
private:
  uint32_t	_reg1;
  uint32_t	_reg2;
  uint32_t	_reg3;
  uint32_t	_reg4;
  uint32_t	_reg5;
  uint32_t	_reg6;
  uint32_t	_reg7;
  uint32_t	_reg8;
  uint32_t	_reg9;
  uint32_t	_reg10;
  uint32_t	_reg11;
  uint32_t	_reg12;
  uint32_t	_reg13;
  uint32_t	_reg14;
  uint32_t	_reg15;
  uint32_t	_reg16;
  uint32_t	_reg17;
  uint32_t	_reg18;
  uint32_t	_reg19;
  uint32_t	_reg20;
  uint32_t	_reg21;
  uint32_t	_reg22;
  uint32_t	_reg23;
  uint32_t	_reg24;
  uint32_t	_reg25;
};
#pragma pack(pop)

/** @class Config100aV1


*/

#pragma pack(push,4)

class Config100aV1 {
public:
  enum { TypeId = Pds::TypeId::Id_Epix100aConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
//  Config100aV1(uint32_t arg__version, uint32_t arg__runTrigDelay, uint32_t arg__daqTrigDelay, uint32_t arg__dacSetting, uint8_t arg__asicGR, uint8_t arg__asicAcq, uint8_t arg__asicR0, uint8_t arg__asicPpmat, uint8_t arg__asicPpbe, uint8_t arg__asicRoClk, uint8_t arg__asicGRControl, uint8_t arg__asicAcqControl, uint8_t arg__asicR0Control, uint8_t arg__asicPpmatControl, uint8_t arg__asicPpbeControl, uint8_t arg__asicR0ClkControl, uint8_t arg__prepulseR0En, uint32_t arg__adcStreamMode, uint8_t arg__testPatternEnable, uint8_t arg__SyncMode, uint8_t arg__R0Mode, uint32_t arg__acqToAsicR0Delay, uint32_t arg__asicR0ToAsicAcq, uint32_t arg__asicAcqWidth, uint32_t arg__asicAcqLToPPmatL, uint32_t arg__asicPPmatToReadout, uint32_t arg__asicRoClkHalfT, uint32_t arg__adcReadsPerPixel, uint32_t arg__adcClkHalfT, uint32_t arg__asicR0Width, uint32_t arg__adcPipelineDelay, uint16_t arg__SyncWidth, uint16_t arg__SyncDelay, uint32_t arg__prepulseR0Width, uint32_t arg__prepulseR0Delay, uint32_t arg__digitalCardId0, uint32_t arg__digitalCardId1, uint32_t arg__analogCardId0, uint32_t arg__analogCardId1, uint32_t arg__numberOfAsicsPerRow, uint32_t arg__numberOfAsicsPerColumn, uint32_t arg__numberOfRowsPerAsic, uint32_t arg__numberOfReadableRowsPerAsic, uint32_t arg__numberOfPixelsPerAsicRow, uint32_t arg__calibrationRowCountPerASIC, uint32_t arg__environmentalRowCountPerASIC, uint32_t arg__baseClockFrequency, uint32_t arg__asicMask, uint8_t arg__scopeEnable, uint8_t arg__scopeTrigEdge, uint8_t arg__scopeTrigChan, uint8_t arg__scopeArmMode, uint16_t arg__scopeADCThreshold, uint16_t arg__scopeTrigHoldoff, uint16_t arg__scopeTrigOffset, uint16_t arg__scopeTraceLength, uint16_t arg__scopeADCsameplesToSkip, uint8_t arg__scopeChanAwaveformSelect, uint8_t arg__scopeChanBwaveformSelect, const Epix::Asic100aConfigV1* arg__asics, const uint16_t* arg__asicPixelConfigArray, const uint8_t* arg__calibPixelConfigArray);
//  Config100aV1(uint32_t numberOfAsicsPerRow, uint32_t numberOfAsicsPerColumn, uint32_t numberOfRowsPerAsic, uint32_t numberOfPixelsPerAsicRow, uint32_t calibrationRowCountPerASIC)
//    : _numberOfAsicsPerRow(numberOfAsicsPerRow), _numberOfAsicsPerColumn(numberOfAsicsPerColumn), _numberOfRowsPerAsic(numberOfRowsPerAsic), _numberOfPixelsPerAsicRow(numberOfPixelsPerAsicRow), _calibrationRowCountPerASIC(calibrationRowCountPerASIC)
//  {
//  }
  Config100aV1() {}
//  Config100aV1(const Config100aV1& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//  }
//  Config100aV1& operator=(const Config100aV1& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//    return *this;
//  }
  uint32_t version() const { return _version; }
  uint32_t runTrigDelay() const { return _runTrigDelay; }
  uint32_t daqTrigDelay() const { return _daqTrigDelay; }
  uint32_t dacSetting() const { return _dacSetting; }
  uint8_t asicGR() const { return uint8_t(this->_asicPins & 0x1); }
  uint8_t asicAcq() const { return uint8_t((this->_asicPins>>1) & 0x1); }
  uint8_t asicR0() const { return uint8_t((this->_asicPins>>2) & 0x1); }
  uint8_t asicPpmat() const { return uint8_t((this->_asicPins>>3) & 0x1); }
  uint8_t asicPpbe() const { return uint8_t((this->_asicPins>>4) & 0x1); }
  uint8_t asicRoClk() const { return uint8_t((this->_asicPins>>5) & 0x1); }
  uint8_t asicGRControl() const { return uint8_t(this->_asicControls & 0x1); }
  uint8_t asicAcqControl() const { return uint8_t((this->_asicControls>>1) & 0x1); }
  uint8_t asicR0Control() const { return uint8_t((this->_asicControls>>2) & 0x1); }
  uint8_t asicPpmatControl() const { return uint8_t((this->_asicControls>>3) & 0x1); }
  uint8_t asicPpbeControl() const { return uint8_t((this->_asicControls>>4) & 0x1); }
  uint8_t asicR0ClkControl() const { return uint8_t((this->_asicControls>>5) & 0x1); }
  uint8_t prepulseR0En() const { return uint8_t((this->_asicControls>>6) & 0x1); }
  uint32_t adcStreamMode() const { return uint32_t((this->_asicControls>>7) & 0x1); }
  uint8_t testPatternEnable() const { return uint8_t((this->_asicControls>>8) & 0x1); }
  uint8_t SyncMode() const { return uint8_t((this->_asicControls>>9) & 0x3); }
  uint8_t R0Mode() const { return uint8_t((this->_asicControls>>11) & 0x1); }
  uint32_t acqToAsicR0Delay() const { return _acqToAsicR0Delay; }
  uint32_t asicR0ToAsicAcq() const { return _asicR0ToAsicAcq; }
  uint32_t asicAcqWidth() const { return _asicAcqWidth; }
  uint32_t asicAcqLToPPmatL() const { return _asicAcqLToPPmatL; }
  uint32_t asicPPmatToReadout() const { return _asicPPmatToReadout; }
  uint32_t asicRoClkHalfT() const { return _asicRoClkHalfT; }
  uint32_t adcReadsPerPixel() const { return _adcReadsPerPixel; }
  uint32_t adcClkHalfT() const { return _adcClkHalfT; }
  uint32_t asicR0Width() const { return _asicR0Width; }
  uint32_t adcPipelineDelay() const { return _adcPipelineDelay; }
  uint16_t SyncWidth() const { return uint16_t(this->_Sync & 0xffff); }
  uint16_t SyncDelay() const { return uint16_t((this->_Sync>>16) & 0xffff); }
  uint32_t prepulseR0Width() const { return _prepulseR0Width; }
  uint32_t prepulseR0Delay() const { return _prepulseR0Delay; }
  uint32_t digitalCardId0() const { return _digitalCardId0; }
  uint32_t digitalCardId1() const { return _digitalCardId1; }
  uint32_t analogCardId0() const { return _analogCardId0; }
  uint32_t analogCardId1() const { return _analogCardId1; }
  uint32_t numberOfAsicsPerRow() const { return _numberOfAsicsPerRow; }
  uint32_t numberOfAsicsPerColumn() const { return _numberOfAsicsPerColumn; }
  uint32_t numberOfRowsPerAsic() const { return _numberOfRowsPerAsic; }
  uint32_t numberOfReadableRowsPerAsic() const { return _numberOfReadableRowsPerAsic; }
  /** for epix100a  352 */
  uint32_t numberOfPixelsPerAsicRow() const { return _numberOfPixelsPerAsicRow; }
  /** for epix100a 96*4 = 384 */
  uint32_t calibrationRowCountPerASIC() const { return _calibrationRowCountPerASIC; }
  uint32_t environmentalRowCountPerASIC() const { return _environmentalRowCountPerASIC; }
  uint32_t baseClockFrequency() const { return _baseClockFrequency; }
  uint32_t asicMask() const { return _asicMask; }
  uint8_t scopeEnable() const { return uint8_t(this->_Scope & 0x1); }
  uint8_t scopeTrigEdge() const { return uint8_t((this->_Scope>>1) & 0x1); }
  uint8_t scopeTrigChan() const { return uint8_t((this->_Scope>>2) & 0xf); }
  uint8_t scopeArmMode() const { return uint8_t((this->_Scope>>6) & 0x3); }
  uint16_t scopeADCThreshold() const { return uint16_t((this->_Scope>>16) & 0xffff); }
  uint16_t scopeTrigHoldoff() const { return uint16_t(this->_ScopeTriggerParms_1 & 0x1fff); }
  uint16_t scopeTrigOffset() const { return uint16_t((this->_ScopeTriggerParms_1>>13) & 0x1fff); }
  uint16_t scopeTraceLength() const { return uint16_t(this->_ScopeTriggerParms_2 & 0x1fff); }
  uint16_t scopeADCsameplesToSkip() const { return uint16_t((this->_ScopeTriggerParms_2>>13) & 0x1fff); }
  uint8_t scopeChanAwaveformSelect() const { return uint8_t(this->_ScopeWaveformSelects & 0x1f); }
  uint8_t scopeChanBwaveformSelect() const { return uint8_t((this->_ScopeWaveformSelects>>5) & 0x1f); }
  const Epix::Asic100aConfigV1& asics(uint32_t i0) const { ptrdiff_t offset=144;
  const Epix::Asic100aConfigV1* memptr = (const Epix::Asic100aConfigV1*)(((const char*)this)+offset);
  size_t memsize = memptr->_sizeof();
  return *(const Epix::Asic100aConfigV1*)((const char*)memptr + (i0)*memsize); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> asicPixelConfigArray(const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=144+(100*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data),  this->numberOfRows(),  this->numberOfColumns());
//  }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> asicPixelConfigArray() const { ptrdiff_t offset=144+(100*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data,  this->numberOfRows(),  this->numberOfColumns()); }
//  /** Calibration row config map is one row for every two calib rows
//
//    Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint8_t, 2> calibPixelConfigArray(const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=(144+(100*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*(( this->numberOfRows())*( this->numberOfColumns())));
//    const uint8_t* data = (const uint8_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint8_t>(owner, data),  this->numberOfCalibrationRows()  / 2 ,  this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow());
//  }
//  /** Calibration row config map is one row for every two calib rows
//
//    Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint8_t, 2> calibPixelConfigArray() const { ptrdiff_t offset=(144+(100*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*(( this->numberOfRows())*( this->numberOfColumns())));
//  const uint8_t* data = (const uint8_t*)(((char*)this)+offset);
//  return make_ndarray(data,  this->numberOfCalibrationRows()  / 2 ,  this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow()); }
  /** Number of pixel rows in a readout unit */
  uint32_t numberOfRows() const { return this->numberOfAsicsPerColumn()*this->numberOfRowsPerAsic(); }
  /** Number of readable pixel rows in a readout unit */
  uint32_t numberOfReadableRows() const { return this->numberOfAsicsPerColumn()*this->numberOfReadableRowsPerAsic(); }
  /** Number of pixel columns in a readout unit */
  uint32_t numberOfColumns() const { return  this->numberOfAsicsPerRow()*this->numberOfPixelsPerAsicRow(); }
  /** Number of calibration rows in a readout unit */
  uint32_t numberOfCalibrationRows() const { return this->numberOfAsicsPerColumn()*this->calibrationRowCountPerASIC(); }
  /** Number of rows in a readout unit */
  uint32_t numberOfEnvironmentalRows() const { return this->numberOfAsicsPerColumn()*this->environmentalRowCountPerASIC(); }
  /** Number of columns in a readout unit */
  uint32_t numberOfAsics() const { return  this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(); }
  uint32_t _sizeof() const { return ((((((144+(Epix::Asic100aConfigV1::_sizeof()*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*( this->numberOfRows())*( this->numberOfColumns())))+(1*( this->numberOfCalibrationRows()  / 2 )*( this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow())))+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by asics() method. */
  std::vector<int> asics_shape() const;
private:
  uint32_t	_version;
  uint32_t	_runTrigDelay;
  uint32_t	_daqTrigDelay;
  uint32_t	_dacSetting;
  uint32_t	_asicPins;
  uint32_t	_asicControls;
  uint32_t	_acqToAsicR0Delay;
  uint32_t	_asicR0ToAsicAcq;
  uint32_t	_asicAcqWidth;
  uint32_t	_asicAcqLToPPmatL;
  uint32_t	_asicPPmatToReadout;
  uint32_t	_asicRoClkHalfT;
  uint32_t	_adcReadsPerPixel;
  uint32_t	_adcClkHalfT;
  uint32_t	_asicR0Width;
  uint32_t	_adcPipelineDelay;
  uint32_t	_Sync;	/**< new */
  uint32_t	_prepulseR0Width;
  uint32_t	_prepulseR0Delay;
  uint32_t	_digitalCardId0;
  uint32_t	_digitalCardId1;
  uint32_t	_analogCardId0;
  uint32_t	_analogCardId1;
  uint32_t	_numberOfAsicsPerRow;
  uint32_t	_numberOfAsicsPerColumn;
  uint32_t	_numberOfRowsPerAsic;
  uint32_t	_numberOfReadableRowsPerAsic;
  uint32_t	_numberOfPixelsPerAsicRow;	/**< for epix100a  352 */
  uint32_t	_calibrationRowCountPerASIC;	/**< for epix100a 96*4 = 384 */
  uint32_t	_environmentalRowCountPerASIC;
  uint32_t	_baseClockFrequency;
  uint32_t	_asicMask;
  uint32_t	_Scope;
  uint32_t	_ScopeTriggerParms_1;
  uint32_t	_ScopeTriggerParms_2;
  uint32_t	_ScopeWaveformSelects;
  //Epix::Asic100aConfigV1	_asics[this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()];
  //uint16_t	_asicPixelConfigArray[ this->numberOfRows()][ this->numberOfColumns()];
  //uint8_t	_calibPixelConfigArray[ this->numberOfCalibrationRows()  / 2 ][ this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow()];
};
#pragma pack(pop)

/** @class Config100aV2


*/

#pragma pack(push,4)

class Config100aV2 {
public:
  enum { TypeId = Pds::TypeId::Id_Epix100aConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
//  Config100aV2(uint32_t arg__version, uint32_t arg__usePgpEvr, uint32_t arg__evrRunCode, uint32_t arg__evrDaqCode, uint32_t arg__evrRunTrigDelay, uint32_t arg__epixRunTrigDelay, uint32_t arg__dacSetting, uint8_t arg__asicGR, uint8_t arg__asicAcq, uint8_t arg__asicR0, uint8_t arg__asicPpmat, uint8_t arg__asicPpbe, uint8_t arg__asicRoClk, uint8_t arg__asicGRControl, uint8_t arg__asicAcqControl, uint8_t arg__asicR0Control, uint8_t arg__asicPpmatControl, uint8_t arg__asicPpbeControl, uint8_t arg__asicR0ClkControl, uint8_t arg__prepulseR0En, uint32_t arg__adcStreamMode, uint8_t arg__testPatternEnable, uint8_t arg__SyncMode, uint8_t arg__R0Mode, uint32_t arg__acqToAsicR0Delay, uint32_t arg__asicR0ToAsicAcq, uint32_t arg__asicAcqWidth, uint32_t arg__asicAcqLToPPmatL, uint32_t arg__asicPPmatToReadout, uint32_t arg__asicRoClkHalfT, uint32_t arg__adcReadsPerPixel, uint32_t arg__adcClkHalfT, uint32_t arg__asicR0Width, uint32_t arg__adcPipelineDelay, uint32_t arg__adcPipelineDelay0, uint32_t arg__adcPipelineDelay1, uint32_t arg__adcPipelineDelay2, uint32_t arg__adcPipelineDelay3, uint16_t arg__SyncWidth, uint16_t arg__SyncDelay, uint32_t arg__prepulseR0Width, uint32_t arg__prepulseR0Delay, uint32_t arg__digitalCardId0, uint32_t arg__digitalCardId1, uint32_t arg__analogCardId0, uint32_t arg__analogCardId1, uint32_t arg__carrierId0, uint32_t arg__carrierId1, uint32_t arg__numberOfAsicsPerRow, uint32_t arg__numberOfAsicsPerColumn, uint32_t arg__numberOfRowsPerAsic, uint32_t arg__numberOfReadableRowsPerAsic, uint32_t arg__numberOfPixelsPerAsicRow, uint32_t arg__calibrationRowCountPerASIC, uint32_t arg__environmentalRowCountPerASIC, uint32_t arg__baseClockFrequency, uint32_t arg__asicMask, uint32_t arg__enableAutomaticRunTrigger, uint32_t arg__numberOf125MhzTicksPerRunTrigger, uint8_t arg__scopeEnable, uint8_t arg__scopeTrigEdge, uint8_t arg__scopeTrigChan, uint8_t arg__scopeArmMode, uint16_t arg__scopeADCThreshold, uint16_t arg__scopeTrigHoldoff, uint16_t arg__scopeTrigOffset, uint16_t arg__scopeTraceLength, uint16_t arg__scopeADCsameplesToSkip, uint8_t arg__scopeChanAwaveformSelect, uint8_t arg__scopeChanBwaveformSelect, const Epix::Asic100aConfigV1* arg__asics, const uint16_t* arg__asicPixelConfigArray, const uint8_t* arg__calibPixelConfigArray);
//  Config100aV2(uint32_t numberOfAsicsPerRow, uint32_t numberOfAsicsPerColumn, uint32_t numberOfRowsPerAsic, uint32_t numberOfPixelsPerAsicRow, uint32_t calibrationRowCountPerASIC)
//    : _numberOfAsicsPerRow(numberOfAsicsPerRow), _numberOfAsicsPerColumn(numberOfAsicsPerColumn), _numberOfRowsPerAsic(numberOfRowsPerAsic), _numberOfPixelsPerAsicRow(numberOfPixelsPerAsicRow), _calibrationRowCountPerASIC(calibrationRowCountPerASIC)
//  {
//  }
  Config100aV2() {}
//  Config100aV2(const Config100aV2& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//  }
//  Config100aV2& operator=(const Config100aV2& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//    return *this;
//  }
  uint32_t version() const { return _version; }
  uint32_t usePgpEvr() const { return _usePgpEvr; }
  uint32_t evrRunCode() const { return _evrRunCode; }
  uint32_t evrDaqCode() const { return _evrDaqCode; }
  uint32_t evrRunTrigDelay() const { return _evrRunTrigDelay; }
  uint32_t epixRunTrigDelay() const { return _epixRunTrigDelay; }
  uint32_t dacSetting() const { return _dacSetting; }
  uint8_t asicGR() const { return uint8_t(this->_asicPins & 0x1); }
  uint8_t asicAcq() const { return uint8_t((this->_asicPins>>1) & 0x1); }
  uint8_t asicR0() const { return uint8_t((this->_asicPins>>2) & 0x1); }
  uint8_t asicPpmat() const { return uint8_t((this->_asicPins>>3) & 0x1); }
  uint8_t asicPpbe() const { return uint8_t((this->_asicPins>>4) & 0x1); }
  uint8_t asicRoClk() const { return uint8_t((this->_asicPins>>5) & 0x1); }
  uint8_t asicGRControl() const { return uint8_t(this->_asicControls & 0x1); }
  uint8_t asicAcqControl() const { return uint8_t((this->_asicControls>>1) & 0x1); }
  uint8_t asicR0Control() const { return uint8_t((this->_asicControls>>2) & 0x1); }
  uint8_t asicPpmatControl() const { return uint8_t((this->_asicControls>>3) & 0x1); }
  uint8_t asicPpbeControl() const { return uint8_t((this->_asicControls>>4) & 0x1); }
  uint8_t asicR0ClkControl() const { return uint8_t((this->_asicControls>>5) & 0x1); }
  uint8_t prepulseR0En() const { return uint8_t((this->_asicControls>>6) & 0x1); }
  uint32_t adcStreamMode() const { return uint32_t((this->_asicControls>>7) & 0x1); }
  uint8_t testPatternEnable() const { return uint8_t((this->_asicControls>>8) & 0x1); }
  uint8_t SyncMode() const { return uint8_t((this->_asicControls>>9) & 0x3); }
  uint8_t R0Mode() const { return uint8_t((this->_asicControls>>11) & 0x1); }
  uint32_t acqToAsicR0Delay() const { return _acqToAsicR0Delay; }
  uint32_t asicR0ToAsicAcq() const { return _asicR0ToAsicAcq; }
  uint32_t asicAcqWidth() const { return _asicAcqWidth; }
  uint32_t asicAcqLToPPmatL() const { return _asicAcqLToPPmatL; }
  uint32_t asicPPmatToReadout() const { return _asicPPmatToReadout; }
  uint32_t asicRoClkHalfT() const { return _asicRoClkHalfT; }
  uint32_t adcReadsPerPixel() const { return _adcReadsPerPixel; }
  uint32_t adcClkHalfT() const { return _adcClkHalfT; }
  uint32_t asicR0Width() const { return _asicR0Width; }
  uint32_t adcPipelineDelay() const { return _adcPipelineDelay; }
  uint32_t adcPipelineDelay0() const { return _adcPipelineDelay0; }
  uint32_t adcPipelineDelay1() const { return _adcPipelineDelay1; }
  uint32_t adcPipelineDelay2() const { return _adcPipelineDelay2; }
  uint32_t adcPipelineDelay3() const { return _adcPipelineDelay3; }
  uint16_t SyncWidth() const { return uint16_t(this->_Sync & 0xffff); }
  uint16_t SyncDelay() const { return uint16_t((this->_Sync>>16) & 0xffff); }
  uint32_t prepulseR0Width() const { return _prepulseR0Width; }
  uint32_t prepulseR0Delay() const { return _prepulseR0Delay; }
  uint32_t digitalCardId0() const { return _digitalCardId0; }
  uint32_t digitalCardId1() const { return _digitalCardId1; }
  uint32_t analogCardId0() const { return _analogCardId0; }
  uint32_t analogCardId1() const { return _analogCardId1; }
  uint32_t carrierId0() const { return _carrierId0; }
  uint32_t carrierId1() const { return _carrierId1; }
  uint32_t numberOfAsicsPerRow() const { return _numberOfAsicsPerRow; }
  uint32_t numberOfAsicsPerColumn() const { return _numberOfAsicsPerColumn; }
  uint32_t numberOfRowsPerAsic() const { return _numberOfRowsPerAsic; }
  uint32_t numberOfReadableRowsPerAsic() const { return _numberOfReadableRowsPerAsic; }
  /** for epix100a  352 */
  uint32_t numberOfPixelsPerAsicRow() const { return _numberOfPixelsPerAsicRow; }
  /** for epix100a 96*4 = 384 */
  uint32_t calibrationRowCountPerASIC() const { return _calibrationRowCountPerASIC; }
  uint32_t environmentalRowCountPerASIC() const { return _environmentalRowCountPerASIC; }
  uint32_t baseClockFrequency() const { return _baseClockFrequency; }
  uint32_t asicMask() const { return _asicMask; }
  uint32_t enableAutomaticRunTrigger() const { return _enableAutomaticRunTrigger; }
  uint32_t numberOf125MhzTicksPerRunTrigger() const { return _numberOf125MhzTicksPerRunTrigger; }
  uint8_t scopeEnable() const { return uint8_t(this->_Scope & 0x1); }
  uint8_t scopeTrigEdge() const { return uint8_t((this->_Scope>>1) & 0x1); }
  uint8_t scopeTrigChan() const { return uint8_t((this->_Scope>>2) & 0xf); }
  uint8_t scopeArmMode() const { return uint8_t((this->_Scope>>6) & 0x3); }
  uint16_t scopeADCThreshold() const { return uint16_t((this->_Scope>>16) & 0xffff); }
  uint16_t scopeTrigHoldoff() const { return uint16_t(this->_ScopeTriggerParms_1 & 0x1fff); }
  uint16_t scopeTrigOffset() const { return uint16_t((this->_ScopeTriggerParms_1>>13) & 0x1fff); }
  uint16_t scopeTraceLength() const { return uint16_t(this->_ScopeTriggerParms_2 & 0x1fff); }
  uint16_t scopeADCsameplesToSkip() const { return uint16_t((this->_ScopeTriggerParms_2>>13) & 0x1fff); }
  uint8_t scopeChanAwaveformSelect() const { return uint8_t(this->_ScopeWaveformSelects & 0x1f); }
  uint8_t scopeChanBwaveformSelect() const { return uint8_t((this->_ScopeWaveformSelects>>5) & 0x1f); }
  const Epix::Asic100aConfigV1& asics(uint32_t i0) const { ptrdiff_t offset=188;
  const Epix::Asic100aConfigV1* memptr = (const Epix::Asic100aConfigV1*)(((const char*)this)+offset);
  size_t memsize = memptr->_sizeof();
  return *(const Epix::Asic100aConfigV1*)((const char*)memptr + (i0)*memsize); }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> asicPixelConfigArray(const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=188+(100*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data),  this->numberOfRows(),  this->numberOfColumns());
//  }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> asicPixelConfigArray() const { ptrdiff_t offset=188+(100*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data,  this->numberOfRows(),  this->numberOfColumns()); }
//  /** Calibration row config map is one row for every two calib rows
//
//    Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint8_t, 2> calibPixelConfigArray(const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=(188+(100*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*(( this->numberOfRows())*( this->numberOfColumns())));
//    const uint8_t* data = (const uint8_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint8_t>(owner, data),  this->numberOfCalibrationRows()  / 2 ,  this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow());
//  }
//  /** Calibration row config map is one row for every two calib rows
//
//    Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint8_t, 2> calibPixelConfigArray() const { ptrdiff_t offset=(188+(100*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*(( this->numberOfRows())*( this->numberOfColumns())));
//  const uint8_t* data = (const uint8_t*)(((char*)this)+offset);
//  return make_ndarray(data,  this->numberOfCalibrationRows()  / 2 ,  this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow()); }
  /** Number of pixel rows in a readout unit */
  uint32_t numberOfRows() const { return this->numberOfAsicsPerColumn()*this->numberOfRowsPerAsic(); }
  /** Number of readable pixel rows in a readout unit */
  uint32_t numberOfReadableRows() const { return this->numberOfAsicsPerColumn()*this->numberOfReadableRowsPerAsic(); }
  /** Number of pixel columns in a readout unit */
  uint32_t numberOfColumns() const { return  this->numberOfAsicsPerRow()*this->numberOfPixelsPerAsicRow(); }
  /** Number of calibration rows in a readout unit */
  uint32_t numberOfCalibrationRows() const { return this->numberOfAsicsPerColumn()*this->calibrationRowCountPerASIC(); }
  /** Number of rows in a readout unit */
  uint32_t numberOfEnvironmentalRows() const { return this->numberOfAsicsPerColumn()*this->environmentalRowCountPerASIC(); }
  /** Number of columns in a readout unit */
  uint32_t numberOfAsics() const { return  this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(); }
  uint32_t _sizeof() const { return ((((((188+(Epix::Asic100aConfigV1::_sizeof()*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*( this->numberOfRows())*( this->numberOfColumns())))+(1*( this->numberOfCalibrationRows()  / 2 )*( this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow())))+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by asics() method. */
  std::vector<int> asics_shape() const;
private:
  uint32_t	_version;
  uint32_t	_usePgpEvr;
  uint32_t	_evrRunCode;
  uint32_t	_evrDaqCode;
  uint32_t	_evrRunTrigDelay;
  uint32_t	_epixRunTrigDelay;
  uint32_t	_dacSetting;
  uint32_t	_asicPins;
  uint32_t	_asicControls;
  uint32_t	_acqToAsicR0Delay;
  uint32_t	_asicR0ToAsicAcq;
  uint32_t	_asicAcqWidth;
  uint32_t	_asicAcqLToPPmatL;
  uint32_t	_asicPPmatToReadout;
  uint32_t	_asicRoClkHalfT;
  uint32_t	_adcReadsPerPixel;
  uint32_t	_adcClkHalfT;
  uint32_t	_asicR0Width;
  uint32_t	_adcPipelineDelay;
  uint32_t	_adcPipelineDelay0;
  uint32_t	_adcPipelineDelay1;
  uint32_t	_adcPipelineDelay2;
  uint32_t	_adcPipelineDelay3;
  uint32_t	_Sync;	/**< new */
  uint32_t	_prepulseR0Width;
  uint32_t	_prepulseR0Delay;
  uint32_t	_digitalCardId0;
  uint32_t	_digitalCardId1;
  uint32_t	_analogCardId0;
  uint32_t	_analogCardId1;
  uint32_t	_carrierId0;
  uint32_t	_carrierId1;
  uint32_t	_numberOfAsicsPerRow;
  uint32_t	_numberOfAsicsPerColumn;
  uint32_t	_numberOfRowsPerAsic;
  uint32_t	_numberOfReadableRowsPerAsic;
  uint32_t	_numberOfPixelsPerAsicRow;	/**< for epix100a  352 */
  uint32_t	_calibrationRowCountPerASIC;	/**< for epix100a 96*4 = 384 */
  uint32_t	_environmentalRowCountPerASIC;
  uint32_t	_baseClockFrequency;
  uint32_t	_asicMask;
  uint32_t	_enableAutomaticRunTrigger;
  uint32_t	_numberOf125MhzTicksPerRunTrigger;
  uint32_t	_Scope;
  uint32_t	_ScopeTriggerParms_1;
  uint32_t	_ScopeTriggerParms_2;
  uint32_t	_ScopeWaveformSelects;
  //Epix::Asic100aConfigV1	_asics[this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()];
  //uint16_t	_asicPixelConfigArray[ this->numberOfRows()][ this->numberOfColumns()];
  //uint8_t	_calibPixelConfigArray[ this->numberOfCalibrationRows()  / 2 ][ this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow()];
};
#pragma pack(pop)

/** @class AsicSConfigV1


*/

#pragma pack(push,4)

class AsicSConfigV1 {
public:
//  AsicSConfigV1(uint8_t arg__pulserSync, uint8_t arg__dummyTest, uint8_t arg__dummyMask, uint16_t arg__testPulserLevel, uint8_t arg__pulserCounterDirection, uint8_t arg__automaticTestModeEnable, uint8_t arg__testMode, uint8_t arg__testModeWithDarkFrame, uint8_t arg__highResolutionModeTest, uint8_t arg__pulserReset, uint8_t arg__digitalMonitorMux1, uint8_t arg__digitalMonitorMux2, uint8_t arg__testPulserCurrent, uint8_t arg__pulserVsPixelOnDelay, uint8_t arg__digitalMonitor1Enable, uint8_t arg__digitalMonitor2Enable, uint8_t arg__inputLeakageCompensation, uint8_t arg__inputLeakageCompensationEnable, uint8_t arg__VRefBaseLineDac, uint8_t arg__extraRowsLowReferenceValue, uint8_t arg__testPointSystemTemperatureCompensationEnable, uint8_t arg__testPointSytemInputSelect, uint8_t arg__programmableReadoutDelay, uint8_t arg__testPointSystemOutputDynamicRange, uint8_t arg__outputDriverOutputDynamicRange, uint8_t arg__balconyEnable, uint8_t arg__balconyDriverCurrent, uint8_t arg__fastPowerPulsingSpeed, uint8_t arg__fastPowerPulsingEnable, uint8_t arg__preamplifierCurrent, uint8_t arg__pixelOutputBufferCurrent, uint8_t arg__pixelBufferAndPreamplifierDrivingCapabilities, uint8_t arg__outputDriverTemperatureCompensationEnable, uint8_t arg__pixelFilterLevel, uint8_t arg__bandGapReferenceTemperatureCompensationBits, uint8_t arg__outputDriverDrivingCapabilitiesAndStability, uint8_t arg__outputDriverDacReferenceBias, uint8_t arg__testPointSystemTemperatureCompensationGain, uint8_t arg__testPointSystemInputCommonMode, uint8_t arg__outputDriverTemperatureCompensationGain, uint8_t arg__outputDriverInputCommonMode, uint8_t arg__testBackEnd, uint8_t arg__interleavedReadOutEnable, uint8_t arg_EXEC_DelayEnable, uint8_t arg__CCK_RegDelayEnable, uint8_t arg__syncPinEnable, uint8_t arg__LVDS_ImpedenceMatchingEnable, uint16_t arg__RowStartAddr, uint16_t arg__RowStopAddr, uint8_t arg__ColumnStartAddr, uint8_t arg__ColumnStopAddr, uint16_t arg__chipID);
  AsicSConfigV1() {}
//  AsicSConfigV1(const AsicSConfigV1& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//  }
//  AsicSConfigV1& operator=(const AsicSConfigV1& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//    return *this;
//  }
  uint8_t pulserSync() const { return uint8_t((this->_reg1>>7) & 0x1); }
  uint8_t dummyTest() const { return uint8_t(this->_reg2 & 0x1); }
  uint8_t dummyMask() const { return uint8_t((this->_reg2>>1) & 0x1); }
  uint16_t testPulserLevel() const { return uint16_t(this->_reg3 & 0x3ff); }
  uint8_t pulserCounterDirection() const { return uint8_t((this->_reg3>>10) & 0x1); }
  uint8_t automaticTestModeEnable() const { return uint8_t((this->_reg3>>11) & 0x1); }
  uint8_t testMode() const { return uint8_t((this->_reg3>>12) & 0x1); }
  uint8_t testModeWithDarkFrame() const { return uint8_t((this->_reg3>>13) & 0x1); }
  uint8_t highResolutionModeTest() const { return uint8_t((this->_reg3>>14) & 0x1); }
  uint8_t pulserReset() const { return uint8_t((this->_reg3>>15) & 0x1); }
  uint8_t digitalMonitorMux1() const { return uint8_t(this->_reg4 & 0xf); }
  uint8_t digitalMonitorMux2() const { return uint8_t((this->_reg4>>4) & 0xf); }
  uint8_t testPulserCurrent() const { return uint8_t(this->_reg5 & 0x7); }
  uint8_t pulserVsPixelOnDelay() const { return uint8_t((this->_reg5>>3) & 0x7); }
  uint8_t digitalMonitor1Enable() const { return uint8_t(this->_reg6 & 0x1); }
  uint8_t digitalMonitor2Enable() const { return uint8_t((this->_reg6>>1) & 0x1); }
  uint8_t inputLeakageCompensation() const { return uint8_t((this->_reg6>>2) & 0x3); }
  uint8_t inputLeakageCompensationEnable() const { return uint8_t((this->_reg6>>4) & 0x1); }
  uint8_t VRefBaselineDac() const { return uint8_t(this->_reg7 & 0x3f); }
  uint8_t extraRowsLowReferenceValue() const { return uint8_t((this->_reg7>>6) & 0x3); }
  uint8_t testPointSystemTemperatureCompensationEnable() const { return uint8_t(this->_reg8 & 0x1); }
  uint8_t testPointSytemInputSelect() const { return uint8_t((this->_reg8>>1) & 0xf); }
  uint8_t programmableReadoutDelay() const { return uint8_t((this->_reg8>>5) & 0x7); }
  uint8_t testPointSystemOutputDynamicRange() const { return uint8_t(this->_reg9 & 0xf); }
  uint8_t outputDriverOutputDynamicRange() const { return uint8_t((this->_reg9>>4) & 0xf); }
  uint8_t balconyEnable() const { return uint8_t(this->_reg10 & 0x1); }
  uint8_t balconyDriverCurrent() const { return uint8_t((this->_reg10>>1) & 0x7); }
  uint8_t fastPowerPulsingSpeed() const { return uint8_t((this->_reg10>>4) & 0x7); }
  uint8_t fastPowerPulsingEnable() const { return uint8_t((this->_reg10>>7) & 0x1); }
  uint8_t preamplifierCurrent() const { return uint8_t(this->_reg11 & 0x7); }
  uint8_t pixelOutputBufferCurrent() const { return uint8_t((this->_reg11>>3) & 0x7); }
  uint8_t pixelBufferAndPreamplifierDrivingCapabilities() const { return uint8_t((this->_reg11>>6) & 0x3); }
  uint8_t outputDriverTemperatureCompensationEnable() const { return uint8_t(this->_reg12 & 0x1); }
  uint8_t pixelFilterLevel() const { return uint8_t((this->_reg12>>1) & 0x3f); }
  uint8_t bandGapReferenceTemperatureCompensationBits() const { return uint8_t(this->_reg13 & 0x3); }
  uint8_t outputDriverDrivingCapabilitiesAndStability() const { return uint8_t((this->_reg13>>2) & 0x7); }
  uint8_t outputDriverDacReferenceBias() const { return uint8_t((this->_reg13>>5) & 0x7); }
  uint8_t testPointSystemTemperatureCompensationGain() const { return uint8_t(this->_reg14 & 0x3); }
  uint8_t testPointSystemInputCommonMode() const { return uint8_t((this->_reg14>>2) & 0x3f); }
  uint8_t outputDriverTemperatureCompensationGain0() const { return uint8_t(this->_reg15 & 0x3); }
  uint8_t outputDriverInputCommonMode0() const { return uint8_t((this->_reg15>>2) & 0x3f); }
  uint8_t testBackEnd() const { return uint8_t(this->_reg16 & 0x1); }
  uint8_t interleavedReadOutEnable() const { return uint8_t((this->_reg16>>1) & 0x1); }
  uint8_t EXEC_DelayEnable() const { return uint8_t((this->_reg16>>2) & 0x1); }
  uint8_t CCK_RegDelayEnable() const { return uint8_t((this->_reg16>>3) & 0x1); }
  uint8_t syncPinEnable() const { return uint8_t((this->_reg16>>4) & 0x1); }
  uint8_t LVDS_ImpedenceMatchingEnable() const { return uint8_t((this->_reg16>>5) & 0x1); }
  uint16_t RowStartAddr() const { return uint16_t(this->_reg17 & 0x1ff); }
  uint16_t RowStopAddr() const { return uint16_t(this->_reg18 & 0x1ff); }
  uint8_t ColumnStartAddr() const { return uint8_t(this->_reg19 & 0x7f); }
  uint8_t ColumnStopAddr() const { return uint8_t(this->_reg20 & 0x7f); }
  uint16_t chipID() const { return uint16_t(this->_reg21 & 0xffff); }
  static uint32_t _sizeof() { return 84; }
private:
  uint32_t	_reg1;
  uint32_t	_reg2;
  uint32_t	_reg3;
  uint32_t	_reg4;
  uint32_t	_reg5;
  uint32_t	_reg6;
  uint32_t	_reg7;
  uint32_t	_reg8;
  uint32_t	_reg9;
  uint32_t	_reg10;
  uint32_t	_reg11;
  uint32_t	_reg12;
  uint32_t	_reg13;
  uint32_t	_reg14;
  uint32_t	_reg15;
  uint32_t	_reg16;
  uint32_t	_reg17;
  uint32_t	_reg18;
  uint32_t	_reg19;
  uint32_t	_reg20;
  uint32_t	_reg21;
};
#pragma pack(pop)

/** @class ConfigSV1


*/

#pragma pack(push,4)

class ConfigSV1 {
public:
  enum { TypeId = Pds::TypeId::Id_EpixSConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
//  ConfigSV1(uint32_t arg__version, uint32_t arg__runTrigDelay, uint32_t arg__daqTrigDelay, uint32_t arg__dacSetting, uint8_t arg__asicGR, uint8_t arg__asicAcq, uint8_t arg__asicR0, uint8_t arg__asicPpmat, uint8_t arg__asicPpbe, uint8_t arg__asicRoClk, uint8_t arg__asicGRControl, uint8_t arg__asicAcqControl, uint8_t arg__asicR0Control, uint8_t arg__asicPpmatControl, uint8_t arg__asicPpbeControl, uint8_t arg__asicR0ClkControl, uint8_t arg__prepulseR0En, uint32_t arg__adcStreamMode, uint8_t arg__testPatternEnable, uint8_t arg__SyncMode, uint8_t arg__R0Mode, uint32_t arg__acqToAsicR0Delay, uint32_t arg__asicR0ToAsicAcq, uint32_t arg__asicAcqWidth, uint32_t arg__asicAcqLToPPmatL, uint32_t arg__asicPPmatToReadout, uint32_t arg__asicRoClkHalfT, uint32_t arg__adcReadsPerPixel, uint32_t arg__adcClkHalfT, uint32_t arg__asicR0Width, uint32_t arg__adcPipelineDelay, uint16_t arg__SyncWidth, uint16_t arg__SyncDelay, uint32_t arg__prepulseR0Width, uint32_t arg__prepulseR0Delay, uint32_t arg__digitalCardId0, uint32_t arg__digitalCardId1, uint32_t arg__analogCardId0, uint32_t arg__analogCardId1, uint32_t arg__carrierId0, uint32_t arg__carrierId1, uint32_t arg__numberOfAsicsPerRow, uint32_t arg__numberOfAsicsPerColumn, uint32_t arg__numberOfRowsPerAsic, uint32_t arg__numberOfReadableRowsPerAsic, uint32_t arg__numberOfPixelsPerAsicRow, uint32_t arg__calibrationRowCountPerASIC, uint32_t arg__environmentalRowCountPerASIC, uint32_t arg__baseClockFrequency, uint32_t arg__asicMask, uint8_t arg__scopeEnable, uint8_t arg__scopeTrigEdge, uint8_t arg__scopeTrigChan, uint8_t arg__scopeArmMode, uint16_t arg__scopeADCThreshold, uint16_t arg__scopeTrigHoldoff, uint16_t arg__scopeTrigOffset, uint16_t arg__scopeTraceLength, uint16_t arg__scopeADCsameplesToSkip, uint8_t arg__scopeChanAwaveformSelect, uint8_t arg__scopeChanBwaveformSelect, const Epix::AsicSConfigV1* arg__asics, const uint16_t* arg__asicPixelConfigArray, const uint8_t* arg__calibPixelConfigArray);
//  ConfigSV1(uint32_t numberOfAsicsPerRow, uint32_t numberOfAsicsPerColumn, uint32_t numberOfRowsPerAsic, uint32_t numberOfPixelsPerAsicRow, uint32_t calibrationRowCountPerASIC)
//    : _numberOfAsicsPerRow(numberOfAsicsPerRow), _numberOfAsicsPerColumn(numberOfAsicsPerColumn), _numberOfRowsPerAsic(numberOfRowsPerAsic), _numberOfPixelsPerAsicRow(numberOfPixelsPerAsicRow), _calibrationRowCountPerASIC(calibrationRowCountPerASIC)
//  {
//  }
  ConfigSV1() {}
//  ConfigSV1(const ConfigSV1& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//  }
//  ConfigSV1& operator=(const ConfigSV1& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//    return *this;
//  }
  uint32_t version() const { return _version; }
  uint32_t runTrigDelay() const { return _runTrigDelay; }
  uint32_t daqTrigDelay() const { return _daqTrigDelay; }
  uint32_t dacSetting() const { return _dacSetting; }
  uint8_t asicGR() const { return uint8_t(this->_asicPins & 0x1); }
  uint8_t asicAcq() const { return uint8_t((this->_asicPins>>1) & 0x1); }
  uint8_t asicR0() const { return uint8_t((this->_asicPins>>2) & 0x1); }
  uint8_t asicPpmat() const { return uint8_t((this->_asicPins>>3) & 0x1); }
  uint8_t asicPpbe() const { return uint8_t((this->_asicPins>>4) & 0x1); }
  uint8_t asicRoClk() const { return uint8_t((this->_asicPins>>5) & 0x1); }
  uint8_t asicGRControl() const { return uint8_t(this->_asicControls & 0x1); }
  uint8_t asicAcqControl() const { return uint8_t((this->_asicControls>>1) & 0x1); }
  uint8_t asicR0Control() const { return uint8_t((this->_asicControls>>2) & 0x1); }
  uint8_t asicPpmatControl() const { return uint8_t((this->_asicControls>>3) & 0x1); }
  uint8_t asicPpbeControl() const { return uint8_t((this->_asicControls>>4) & 0x1); }
  uint8_t asicR0ClkControl() const { return uint8_t((this->_asicControls>>5) & 0x1); }
  uint8_t prepulseR0En() const { return uint8_t((this->_asicControls>>6) & 0x1); }
  uint32_t adcStreamMode() const { return uint32_t((this->_asicControls>>7) & 0x1); }
  uint8_t testPatternEnable() const { return uint8_t((this->_asicControls>>8) & 0x1); }
  uint8_t SyncMode() const { return uint8_t((this->_asicControls>>9) & 0x3); }
  uint8_t R0Mode() const { return uint8_t((this->_asicControls>>11) & 0x1); }
  uint32_t acqToAsicR0Delay() const { return _acqToAsicR0Delay; }
  uint32_t asicR0ToAsicAcq() const { return _asicR0ToAsicAcq; }
  uint32_t asicAcqWidth() const { return _asicAcqWidth; }
  uint32_t asicAcqLToPPmatL() const { return _asicAcqLToPPmatL; }
  uint32_t asicPPmatToReadout() const { return _asicPPmatToReadout; }
  uint32_t asicRoClkHalfT() const { return _asicRoClkHalfT; }
  uint32_t adcReadsPerPixel() const { return _adcReadsPerPixel; }
  uint32_t adcClkHalfT() const { return _adcClkHalfT; }
  uint32_t asicR0Width() const { return _asicR0Width; }
  uint32_t adcPipelineDelay() const { return _adcPipelineDelay; }
  uint16_t SyncWidth() const { return uint16_t(this->_Sync & 0xffff); }
  uint16_t SyncDelay() const { return uint16_t((this->_Sync>>16) & 0xffff); }
  uint32_t prepulseR0Width() const { return _prepulseR0Width; }
  uint32_t prepulseR0Delay() const { return _prepulseR0Delay; }
  uint32_t digitalCardId0() const { return _digitalCardId0; }
  uint32_t digitalCardId1() const { return _digitalCardId1; }
  uint32_t analogCardId0() const { return _analogCardId0; }
  uint32_t analogCardId1() const { return _analogCardId1; }
  uint32_t carrierId0() const { return _carrierId0; }
  uint32_t carrierId1() const { return _carrierId1; }
  uint32_t numberOfAsicsPerRow() const { return _numberOfAsicsPerRow; }
  uint32_t numberOfAsicsPerColumn() const { return _numberOfAsicsPerColumn; }
  uint32_t numberOfRowsPerAsic() const { return _numberOfRowsPerAsic; }
  uint32_t numberOfReadableRowsPerAsic() const { return _numberOfReadableRowsPerAsic; }
  /** for epixS  352 */
  uint32_t numberOfPixelsPerAsicRow() const { return _numberOfPixelsPerAsicRow; }
  /** for epixS 96*4 = 384 */
  uint32_t calibrationRowCountPerASIC() const { return _calibrationRowCountPerASIC; }
  uint32_t environmentalRowCountPerASIC() const { return _environmentalRowCountPerASIC; }
  uint32_t baseClockFrequency() const { return _baseClockFrequency; }
  uint32_t asicMask() const { return _asicMask; }
  uint8_t scopeEnable() const { return uint8_t(this->_Scope & 0x1); }
  uint8_t scopeTrigEdge() const { return uint8_t((this->_Scope>>1) & 0x1); }
  uint8_t scopeTrigChan() const { return uint8_t((this->_Scope>>2) & 0xf); }
  uint8_t scopeArmMode() const { return uint8_t((this->_Scope>>6) & 0x3); }
  uint16_t scopeADCThreshold() const { return uint16_t((this->_Scope>>16) & 0xffff); }
  uint16_t scopeTrigHoldoff() const { return uint16_t(this->_ScopeTriggerParms_1 & 0x1fff); }
  uint16_t scopeTrigOffset() const { return uint16_t((this->_ScopeTriggerParms_1>>13) & 0x1fff); }
  uint16_t scopeTraceLength() const { return uint16_t(this->_ScopeTriggerParms_2 & 0x1fff); }
  uint16_t scopeADCsameplesToSkip() const { return uint16_t((this->_ScopeTriggerParms_2>>13) & 0x1fff); }
  uint8_t scopeChanAwaveformSelect() const { return uint8_t(this->_ScopeWaveformSelects & 0x1f); }
  uint8_t scopeChanBwaveformSelect() const { return uint8_t((this->_ScopeWaveformSelects>>5) & 0x1f); }
  const Epix::AsicSConfigV1& asics(uint32_t i0) const { ptrdiff_t offset=152;
  const Epix::AsicSConfigV1* memptr = (const Epix::AsicSConfigV1*)(((const char*)this)+offset);
  size_t memsize = memptr->_sizeof();
  return *(const Epix::AsicSConfigV1*)((const char*)memptr + (i0)*memsize); }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> asicPixelConfigArray(const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=152+(84*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data),  this->numberOfRows(),  this->numberOfColumns());
//  }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> asicPixelConfigArray() const { ptrdiff_t offset=152+(84*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data,  this->numberOfRows(),  this->numberOfColumns()); }
//  /** Calibration row config map is one row for every two calib rows
//
//    Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint8_t, 2> calibPixelConfigArray(const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=(152+(84*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*(( this->numberOfRows())*( this->numberOfColumns())));
//    const uint8_t* data = (const uint8_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint8_t>(owner, data),  this->numberOfCalibrationRows()  / 2 ,  this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow());
//  }
//  /** Calibration row config map is one row for every two calib rows
//
//    Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint8_t, 2> calibPixelConfigArray() const { ptrdiff_t offset=(152+(84*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*(( this->numberOfRows())*( this->numberOfColumns())));
//  const uint8_t* data = (const uint8_t*)(((char*)this)+offset);
//  return make_ndarray(data,  this->numberOfCalibrationRows()  / 2 ,  this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow()); }
  /** Number of pixel rows in a readout unit */
  uint32_t numberOfRows() const { return this->numberOfAsicsPerColumn()*this->numberOfRowsPerAsic(); }
  /** Number of readable pixel rows in a readout unit */
  uint32_t numberOfReadableRows() const { return this->numberOfAsicsPerColumn()*this->numberOfReadableRowsPerAsic(); }
  /** Number of pixel columns in a readout unit */
  uint32_t numberOfColumns() const { return  this->numberOfAsicsPerRow()*this->numberOfPixelsPerAsicRow(); }
  /** Number of calibration rows in a readout unit */
  uint32_t numberOfCalibrationRows() const { return this->numberOfAsicsPerColumn()*this->calibrationRowCountPerASIC(); }
  /** Number of rows in a readout unit */
  uint32_t numberOfEnvironmentalRows() const { return this->numberOfAsicsPerColumn()*this->environmentalRowCountPerASIC(); }
  /** Number of columns in a readout unit */
  uint32_t numberOfAsics() const { return  this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(); }
  uint32_t _sizeof() const { return ((((((152+(Epix::AsicSConfigV1::_sizeof()*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*( this->numberOfRows())*( this->numberOfColumns())))+(1*( this->numberOfCalibrationRows()  / 2 )*( this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow())))+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by asics() method. */
  std::vector<int> asics_shape() const;
private:
  uint32_t	_version;
  uint32_t	_runTrigDelay;
  uint32_t	_daqTrigDelay;
  uint32_t	_dacSetting;
  uint32_t	_asicPins;
  uint32_t	_asicControls;
  uint32_t	_acqToAsicR0Delay;
  uint32_t	_asicR0ToAsicAcq;
  uint32_t	_asicAcqWidth;
  uint32_t	_asicAcqLToPPmatL;
  uint32_t	_asicPPmatToReadout;
  uint32_t	_asicRoClkHalfT;
  uint32_t	_adcReadsPerPixel;
  uint32_t	_adcClkHalfT;
  uint32_t	_asicR0Width;
  uint32_t	_adcPipelineDelay;
  uint32_t	_Sync;	/**< new */
  uint32_t	_prepulseR0Width;
  uint32_t	_prepulseR0Delay;
  uint32_t	_digitalCardId0;
  uint32_t	_digitalCardId1;
  uint32_t	_analogCardId0;
  uint32_t	_analogCardId1;
  uint32_t	_carrierId0;
  uint32_t	_carrierId1;
  uint32_t	_numberOfAsicsPerRow;
  uint32_t	_numberOfAsicsPerColumn;
  uint32_t	_numberOfRowsPerAsic;
  uint32_t	_numberOfReadableRowsPerAsic;
  uint32_t	_numberOfPixelsPerAsicRow;	/**< for epixS  352 */
  uint32_t	_calibrationRowCountPerASIC;	/**< for epixS 96*4 = 384 */
  uint32_t	_environmentalRowCountPerASIC;
  uint32_t	_baseClockFrequency;
  uint32_t	_asicMask;
  uint32_t	_Scope;
  uint32_t	_ScopeTriggerParms_1;
  uint32_t	_ScopeTriggerParms_2;
  uint32_t	_ScopeWaveformSelects;
  //Epix::AsicSConfigV1	_asics[this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()];
  //uint16_t	_asicPixelConfigArray[ this->numberOfRows()][ this->numberOfColumns()];
  //uint8_t	_calibPixelConfigArray[ this->numberOfCalibrationRows()  / 2 ][ this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow()];
};
#pragma pack(pop)

/** @class Asic10kaConfigV1


*/

#pragma pack(push,4)

class Asic10kaConfigV1 {
public:
//  Asic10kaConfigV1(uint8_t arg__CompTH_DAC, uint8_t arg__CompEn_lowBit, uint8_t arg__PulserSync, uint8_t arg__pixelDummy, uint16_t arg__Pulser, uint8_t arg__Pbit, uint8_t arg__atest, uint8_t arg__test, uint8_t arg__Sab_test, uint8_t arg__Hrtest, uint8_t arg__PulserR, uint8_t arg__DM1, uint8_t arg__DM2, uint8_t arg__Pulser_DAC, uint8_t arg__Monost_Pulser, uint8_t arg__CompEn_topTwoBits, uint8_t arg__DM1en, uint8_t arg__DM2en, uint8_t arg__emph_bd, uint8_t arg__emph_bc, uint8_t arg__VREF_DAC, uint8_t arg__VrefLow, uint8_t arg__TPS_tcomp, uint8_t arg__TPS_MUX, uint8_t arg__RO_Monost, uint8_t arg__TPS_GR, uint8_t arg__S2D0_GR, uint8_t arg__PP_OCB_S2D, uint8_t arg__OCB, uint8_t arg__Monost, uint8_t arg__fastPP_enable, uint8_t arg__Preamp, uint8_t arg__Pixel_CB, uint8_t arg__Vld1_b, uint8_t arg__S2D_tcomp, uint8_t arg__Filter_DAC, uint8_t arg__testLVDTransmitter, uint8_t arg__tc, uint8_t arg__S2D, uint8_t arg__S2D_DAC_Bias, uint8_t arg__TPS_tcDAC, uint8_t arg__TPS_DAC, uint8_t arg__S2D0_tcDAC, uint8_t arg__S2D0_DAC, uint8_t arg__testBE, uint8_t arg__is_en, uint8_t arg__DelEXEC, uint8_t arg__DelCCKreg, uint8_t arg__RO_rst_en, uint8_t arg__SLVDSbit, uint8_t arg__FELmode, uint8_t arg__CompEnOn, uint16_t arg__RowStart, uint16_t arg__RowStop, uint8_t arg__ColumnStart, uint8_t arg__ColumnStop, uint16_t arg__chipID, uint8_t arg__S2D1_GR, uint8_t arg__S2D2_GR, uint8_t arg__S2D3_GR, uint8_t arg__trbit, uint8_t arg__S2D1_tcDAC, uint8_t arg__S2D1_DAC, uint8_t arg__S2D2_tcDAC, uint8_t arg__S2D2_DAC, uint8_t arg__S2D3_tcDAC, uint8_t arg__S2D3_DAC);
  Asic10kaConfigV1() {}
  Asic10kaConfigV1(const Asic10kaConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  Asic10kaConfigV1& operator=(const Asic10kaConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint8_t CompTH_DAC() const { return uint8_t(this->_reg1 & 0x3f); }
  uint8_t CompEn_lowBit() const { return uint8_t((this->_reg1>>6) & 0x1); }
  uint8_t PulserSync() const { return uint8_t((this->_reg1>>7) & 0x1); }
  uint8_t pixelDummy() const { return uint8_t(this->_reg2 & 0xff); }
  uint16_t Pulser() const { return uint16_t(this->_reg3 & 0x3ff); }
  uint8_t Pbit() const { return uint8_t((this->_reg3>>10) & 0x1); }
  uint8_t atest() const { return uint8_t((this->_reg3>>11) & 0x1); }
  uint8_t test() const { return uint8_t((this->_reg3>>12) & 0x1); }
  uint8_t Sab_test() const { return uint8_t((this->_reg3>>13) & 0x1); }
  uint8_t Hrtest() const { return uint8_t((this->_reg3>>14) & 0x1); }
  uint8_t PulserR() const { return uint8_t((this->_reg3>>15) & 0x1); }
  uint8_t DM1() const { return uint8_t(this->_reg4 & 0xf); }
  uint8_t DM2() const { return uint8_t((this->_reg4>>4) & 0xf); }
  uint8_t Pulser_DAC() const { return uint8_t(this->_reg5 & 0x7); }
  uint8_t Monost_Pulser() const { return uint8_t((this->_reg5>>3) & 0x7); }
  uint8_t CompEn_topTwoBits() const { return uint8_t((this->_reg5>>6) & 0x3); }
  uint8_t DM1en() const { return uint8_t(this->_reg6 & 0x1); }
  uint8_t DM2en() const { return uint8_t((this->_reg6>>1) & 0x1); }
  uint8_t emph_bd() const { return uint8_t((this->_reg6>>2) & 0x7); }
  uint8_t emph_bc() const { return uint8_t((this->_reg6>>5) & 0x7); }
  uint8_t VREF_DAC() const { return uint8_t(this->_reg7 & 0x3f); }
  uint8_t VrefLow() const { return uint8_t((this->_reg7>>6) & 0x3); }
  uint8_t TPS_tcomp() const { return uint8_t(this->_reg8 & 0x1); }
  uint8_t TPS_MUX() const { return uint8_t((this->_reg8>>1) & 0xf); }
  uint8_t RO_Monost() const { return uint8_t((this->_reg8>>5) & 0x7); }
  uint8_t TPS_GR() const { return uint8_t(this->_reg9 & 0xf); }
  uint8_t S2D0_GR() const { return uint8_t((this->_reg9>>4) & 0xf); }
  uint8_t PP_OCB_S2D() const { return uint8_t(this->_reg10 & 0x1); }
  uint8_t OCB() const { return uint8_t((this->_reg10>>1) & 0x7); }
  uint8_t Monost() const { return uint8_t((this->_reg10>>4) & 0x7); }
  uint8_t fastPP_enable() const { return uint8_t((this->_reg10>>7) & 0x1); }
  uint8_t Preamp() const { return uint8_t(this->_reg11 & 0x7); }
  uint8_t PixelCB() const { return uint8_t((this->_reg11>>3) & 0x7); }
  uint8_t Vld1_b() const { return uint8_t((this->_reg11>>6) & 0x3); }
  uint8_t S2D_tcomp() const { return uint8_t(this->_reg12 & 0x1); }
  uint8_t Filter_DAC() const { return uint8_t((this->_reg12>>1) & 0x3f); }
  uint8_t testLVDTransmitter() const { return uint8_t((this->_reg12>>7) & 0x1); }
  uint8_t tc() const { return uint8_t(this->_reg13 & 0x3); }
  uint8_t S2D() const { return uint8_t((this->_reg13>>2) & 0x7); }
  uint8_t S2D_DAC_Bias() const { return uint8_t((this->_reg13>>5) & 0x7); }
  uint8_t TPS_tcDAC() const { return uint8_t(this->_reg14 & 0x3); }
  uint8_t TPS_DAC() const { return uint8_t((this->_reg14>>2) & 0x3f); }
  uint8_t S2D0_tcDAC() const { return uint8_t(this->_reg15 & 0x3); }
  uint8_t S2D0_DAC() const { return uint8_t((this->_reg15>>2) & 0x3f); }
  uint8_t testBE() const { return uint8_t(this->_reg16 & 0x1); }
  uint8_t is_en() const { return uint8_t((this->_reg16>>1) & 0x1); }
  uint8_t DelEXEC() const { return uint8_t((this->_reg16>>2) & 0x1); }
  uint8_t DelCCKreg() const { return uint8_t((this->_reg16>>3) & 0x1); }
  uint8_t RO_rst_en() const { return uint8_t((this->_reg16>>4) & 0x1); }
  uint8_t SLVDSbit() const { return uint8_t((this->_reg16>>5) & 0x1); }
  uint8_t FELmode() const { return uint8_t((this->_reg16>>6) & 0x1); }
  uint8_t CompEnOn() const { return uint8_t((this->_reg16>>7) & 0x1); }
  uint16_t RowStart() const { return uint16_t(this->_reg17 & 0x1ff); }
  uint16_t RowStop() const { return uint16_t(this->_reg18 & 0x1ff); }
  uint8_t ColumnStart() const { return uint8_t(this->_reg19 & 0x7f); }
  uint8_t ColumnStop() const { return uint8_t(this->_reg20 & 0x7f); }
  uint16_t chipID() const { return uint16_t(this->_reg21 & 0xffff); }
  uint8_t S2D1_GR() const { return uint8_t(this->_reg22 & 0xf); }
  uint8_t S2D2_GR() const { return uint8_t((this->_reg22>>4) & 0xf); }
  uint8_t S2D3_GR() const { return uint8_t(this->_reg23 & 0xf); }
  uint8_t trbit() const { return uint8_t((this->_reg23>>4) & 0x1); }
  uint8_t S2D1_tcDAC() const { return uint8_t(this->_reg24 & 0x3); }
  uint8_t S2D1_DAC() const { return uint8_t((this->_reg24>>2) & 0x3f); }
  uint8_t S2D2_tcDAC() const { return uint8_t(this->_reg25 & 0x3); }
  uint8_t S2D2_DAC() const { return uint8_t((this->_reg25>>2) & 0x3f); }
  uint8_t S2D3_tcDAC() const { return uint8_t(this->_reg26 & 0x3); }
  uint8_t S2D3_DAC() const { return uint8_t((this->_reg26>>2) & 0x3f); }
  static uint32_t _sizeof() { return 104; }
private:
  uint32_t	_reg1;
  uint32_t	_reg2;
  uint32_t	_reg3;
  uint32_t	_reg4;
  uint32_t	_reg5;
  uint32_t	_reg6;
  uint32_t	_reg7;
  uint32_t	_reg8;
  uint32_t	_reg9;
  uint32_t	_reg10;
  uint32_t	_reg11;
  uint32_t	_reg12;
  uint32_t	_reg13;
  uint32_t	_reg14;
  uint32_t	_reg15;
  uint32_t	_reg16;
  uint32_t	_reg17;
  uint32_t	_reg18;
  uint32_t	_reg19;
  uint32_t	_reg20;
  uint32_t	_reg21;
  uint32_t	_reg22;
  uint32_t	_reg23;
  uint32_t	_reg24;
  uint32_t	_reg25;
  uint32_t	_reg26;
};
#pragma pack(pop)

/** @class Config10kaV1


*/

#pragma pack(push,4)

class Config10kaV1 {
public:
  enum { TypeId = Pds::TypeId::Id_Epix10kaConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
//  Config10kaV1(uint32_t arg__version, uint32_t arg__usePgpEvr, uint32_t arg__evrRunCode, uint32_t arg__evrDaqCode, uint32_t arg__evrRunTrigDelay, uint32_t arg__epixRunTrigDelay, uint32_t arg__dacSetting, uint8_t arg__asicGR, uint8_t arg__asicAcq, uint8_t arg__asicR0, uint8_t arg__asicPpmat, uint8_t arg__asicPpbe, uint8_t arg__asicRoClk, uint8_t arg__asicGRControl, uint8_t arg__asicAcqControl, uint8_t arg__asicR0Control, uint8_t arg__asicPpmatControl, uint8_t arg__asicPpbeControl, uint8_t arg__asicR0ClkControl, uint8_t arg__prepulseR0En, uint32_t arg__adcStreamMode, uint8_t arg__testPatternEnable, uint8_t arg__SyncMode, uint8_t arg__R0Mode, uint32_t arg__acqToAsicR0Delay, uint32_t arg__asicR0ToAsicAcq, uint32_t arg__asicAcqWidth, uint32_t arg__asicAcqLToPPmatL, uint32_t arg__asicPPmatToReadout, uint32_t arg__asicRoClkHalfT, uint32_t arg__adcReadsPerPixel, uint32_t arg__adcClkHalfT, uint32_t arg__asicR0Width, uint32_t arg__adcPipelineDelay, uint32_t arg__adcPipelineDelay0, uint32_t arg__adcPipelineDelay1, uint32_t arg__adcPipelineDelay2, uint32_t arg__adcPipelineDelay3, uint16_t arg__SyncWidth, uint16_t arg__SyncDelay, uint32_t arg__prepulseR0Width, uint32_t arg__prepulseR0Delay, uint32_t arg__digitalCardId0, uint32_t arg__digitalCardId1, uint32_t arg__analogCardId0, uint32_t arg__analogCardId1, uint32_t arg__carrierId0, uint32_t arg__carrierId1, uint32_t arg__numberOfAsicsPerRow, uint32_t arg__numberOfAsicsPerColumn, uint32_t arg__numberOfRowsPerAsic, uint32_t arg__numberOfReadableRowsPerAsic, uint32_t arg__numberOfPixelsPerAsicRow, uint32_t arg__calibrationRowCountPerASIC, uint32_t arg__environmentalRowCountPerASIC, uint32_t arg__baseClockFrequency, uint32_t arg__asicMask, uint32_t arg__enableAutomaticRunTrigger, uint32_t arg__numberOf125MhzTicksPerRunTrigger, uint8_t arg__scopeEnable, uint8_t arg__scopeTrigEdge, uint8_t arg__scopeTrigChan, uint8_t arg__scopeArmMode, uint16_t arg__scopeADCThreshold, uint16_t arg__scopeTrigHoldoff, uint16_t arg__scopeTrigOffset, uint16_t arg__scopeTraceLength, uint16_t arg__scopeADCsameplesToSkip, uint8_t arg__scopeChanAwaveformSelect, uint8_t arg__scopeChanBwaveformSelect, const Epix::Asic10kaConfigV1* arg__asics, const uint16_t* arg__asicPixelConfigArray, const uint8_t* arg__calibPixelConfigArray);
//  Config10kaV1(uint32_t numberOfAsicsPerRow, uint32_t numberOfAsicsPerColumn, uint32_t numberOfRowsPerAsic, uint32_t numberOfPixelsPerAsicRow, uint32_t calibrationRowCountPerASIC)
//    : _numberOfAsicsPerRow(numberOfAsicsPerRow), _numberOfAsicsPerColumn(numberOfAsicsPerColumn), _numberOfRowsPerAsic(numberOfRowsPerAsic), _numberOfPixelsPerAsicRow(numberOfPixelsPerAsicRow), _calibrationRowCountPerASIC(calibrationRowCountPerASIC)
//  {
//  }
  Config10kaV1() {}
  Config10kaV1(const Config10kaV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  Config10kaV1& operator=(const Config10kaV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint32_t version() const { return _version; }
  uint32_t usePgpEvr() const { return _usePgpEvr; }
  uint32_t evrRunCode() const { return _evrRunCode; }
  uint32_t evrDaqCode() const { return _evrDaqCode; }
  uint32_t evrRunTrigDelay() const { return _evrRunTrigDelay; }
  uint32_t epixRunTrigDelay() const { return _epixRunTrigDelay; }
  uint32_t dacSetting() const { return _dacSetting; }
  uint8_t asicGR() const { return uint8_t(this->_asicPins & 0x1); }
  uint8_t asicAcq() const { return uint8_t((this->_asicPins>>1) & 0x1); }
  uint8_t asicR0() const { return uint8_t((this->_asicPins>>2) & 0x1); }
  uint8_t asicPpmat() const { return uint8_t((this->_asicPins>>3) & 0x1); }
  uint8_t asicPpbe() const { return uint8_t((this->_asicPins>>4) & 0x1); }
  uint8_t asicRoClk() const { return uint8_t((this->_asicPins>>5) & 0x1); }
  uint8_t asicGRControl() const { return uint8_t(this->_asicControls & 0x1); }
  uint8_t asicAcqControl() const { return uint8_t((this->_asicControls>>1) & 0x1); }
  uint8_t asicR0Control() const { return uint8_t((this->_asicControls>>2) & 0x1); }
  uint8_t asicPpmatControl() const { return uint8_t((this->_asicControls>>3) & 0x1); }
  uint8_t asicPpbeControl() const { return uint8_t((this->_asicControls>>4) & 0x1); }
  uint8_t asicR0ClkControl() const { return uint8_t((this->_asicControls>>5) & 0x1); }
  uint8_t prepulseR0En() const { return uint8_t((this->_asicControls>>6) & 0x1); }
  uint32_t adcStreamMode() const { return uint32_t((this->_asicControls>>7) & 0x1); }
  uint8_t testPatternEnable() const { return uint8_t((this->_asicControls>>8) & 0x1); }
  uint8_t SyncMode() const { return uint8_t((this->_asicControls>>9) & 0x3); }
  uint8_t R0Mode() const { return uint8_t((this->_asicControls>>11) & 0x1); }
  uint32_t acqToAsicR0Delay() const { return _acqToAsicR0Delay; }
  uint32_t asicR0ToAsicAcq() const { return _asicR0ToAsicAcq; }
  uint32_t asicAcqWidth() const { return _asicAcqWidth; }
  uint32_t asicAcqLToPPmatL() const { return _asicAcqLToPPmatL; }
  uint32_t asicPPmatToReadout() const { return _asicPPmatToReadout; }
  uint32_t asicRoClkHalfT() const { return _asicRoClkHalfT; }
  uint32_t adcReadsPerPixel() const { return _adcReadsPerPixel; }
  uint32_t adcClkHalfT() const { return _adcClkHalfT; }
  uint32_t asicR0Width() const { return _asicR0Width; }
  uint32_t adcPipelineDelay() const { return _adcPipelineDelay; }
  uint32_t adcPipelineDelay0() const { return _adcPipelineDelay0; }
  uint32_t adcPipelineDelay1() const { return _adcPipelineDelay1; }
  uint32_t adcPipelineDelay2() const { return _adcPipelineDelay2; }
  uint32_t adcPipelineDelay3() const { return _adcPipelineDelay3; }
  uint16_t SyncWidth() const { return uint16_t(this->_Sync & 0xffff); }
  uint16_t SyncDelay() const { return uint16_t((this->_Sync>>16) & 0xffff); }
  uint32_t prepulseR0Width() const { return _prepulseR0Width; }
  uint32_t prepulseR0Delay() const { return _prepulseR0Delay; }
  uint32_t digitalCardId0() const { return _digitalCardId0; }
  uint32_t digitalCardId1() const { return _digitalCardId1; }
  uint32_t analogCardId0() const { return _analogCardId0; }
  uint32_t analogCardId1() const { return _analogCardId1; }
  uint32_t carrierId0() const { return _carrierId0; }
  uint32_t carrierId1() const { return _carrierId1; }
  uint32_t numberOfAsicsPerRow() const { return _numberOfAsicsPerRow; }
  uint32_t numberOfAsicsPerColumn() const { return _numberOfAsicsPerColumn; }
  uint32_t numberOfRowsPerAsic() const { return _numberOfRowsPerAsic; }
  uint32_t numberOfReadableRowsPerAsic() const { return _numberOfReadableRowsPerAsic; }
  /** for epix10ka  176 */
  uint32_t numberOfPixelsPerAsicRow() const { return _numberOfPixelsPerAsicRow; }
  /** for epix10ka 96*4 = 384 */
  uint32_t calibrationRowCountPerASIC() const { return _calibrationRowCountPerASIC; }
  uint32_t environmentalRowCountPerASIC() const { return _environmentalRowCountPerASIC; }
  uint32_t baseClockFrequency() const { return _baseClockFrequency; }
  uint32_t asicMask() const { return _asicMask; }
  uint32_t enableAutomaticRunTrigger() const { return _enableAutomaticRunTrigger; }
  uint32_t numberOf125MhzTicksPerRunTrigger() const { return _numberOf125MhzTicksPerRunTrigger; }
  uint8_t scopeEnable() const { return uint8_t(this->_Scope & 0x1); }
  uint8_t scopeTrigEdge() const { return uint8_t((this->_Scope>>1) & 0x1); }
  uint8_t scopeTrigChan() const { return uint8_t((this->_Scope>>2) & 0xf); }
  uint8_t scopeArmMode() const { return uint8_t((this->_Scope>>6) & 0x3); }
  uint16_t scopeADCThreshold() const { return uint16_t((this->_Scope>>16) & 0xffff); }
  uint16_t scopeTrigHoldoff() const { return uint16_t(this->_ScopeTriggerParms_1 & 0x1fff); }
  uint16_t scopeTrigOffset() const { return uint16_t((this->_ScopeTriggerParms_1>>13) & 0x1fff); }
  uint16_t scopeTraceLength() const { return uint16_t(this->_ScopeTriggerParms_2 & 0x1fff); }
  uint16_t scopeADCsameplesToSkip() const { return uint16_t((this->_ScopeTriggerParms_2>>13) & 0x1fff); }
  uint8_t scopeChanAwaveformSelect() const { return uint8_t(this->_ScopeWaveformSelects & 0x1f); }
  uint8_t scopeChanBwaveformSelect() const { return uint8_t((this->_ScopeWaveformSelects>>5) & 0x1f); }
  const Epix::Asic10kaConfigV1& asics(uint32_t i0) const { ptrdiff_t offset=188;
  const Epix::Asic10kaConfigV1* memptr = (const Epix::Asic10kaConfigV1*)(((const char*)this)+offset);
  size_t memsize = memptr->_sizeof();
  return *(const Epix::Asic10kaConfigV1*)((const char*)memptr + (i0)*memsize); }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> asicPixelConfigArray(const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=188+(104*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data),  this->numberOfRows(),  this->numberOfColumns());
//  }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> asicPixelConfigArray() const { ptrdiff_t offset=188+(104*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data,  this->numberOfRows(),  this->numberOfColumns()); }
//  /** Calibration row config map is one row for every two calib rows
//
//    Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint8_t, 2> calibPixelConfigArray(const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=(188+(104*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*(( this->numberOfRows())*( this->numberOfColumns())));
//    const uint8_t* data = (const uint8_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint8_t>(owner, data),  this->numberOfCalibrationRows()  / 2 ,  this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow());
//  }
//  /** Calibration row config map is one row for every two calib rows
//
//    Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint8_t, 2> calibPixelConfigArray() const { ptrdiff_t offset=(188+(104*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*(( this->numberOfRows())*( this->numberOfColumns())));
//  const uint8_t* data = (const uint8_t*)(((char*)this)+offset);
//  return make_ndarray(data,  this->numberOfCalibrationRows()  / 2 ,  this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow()); }
  /** Number of pixel rows in a readout unit */
  uint32_t numberOfRows() const { return this->numberOfAsicsPerColumn()*this->numberOfRowsPerAsic(); }
  /** Number of readable pixel rows in a readout unit */
  uint32_t numberOfReadableRows() const { return this->numberOfAsicsPerColumn()*this->numberOfReadableRowsPerAsic(); }
  /** Number of pixel columns in a readout unit */
  uint32_t numberOfColumns() const { return  this->numberOfAsicsPerRow()*this->numberOfPixelsPerAsicRow(); }
  /** Number of calibration rows in a readout unit */
  uint32_t numberOfCalibrationRows() const { return this->numberOfAsicsPerColumn()*this->calibrationRowCountPerASIC(); }
  /** Number of rows in a readout unit */
  uint32_t numberOfEnvironmentalRows() const { return this->numberOfAsicsPerColumn()*this->environmentalRowCountPerASIC(); }
  /** Number of columns in a readout unit */
  uint32_t numberOfAsics() const { return  this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn(); }
  uint32_t _sizeof() const { return ((((((188+(Epix::Asic10kaConfigV1::_sizeof()*(this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn())))+(2*( this->numberOfRows())*( this->numberOfColumns())))+(1*( this->numberOfCalibrationRows()  / 2 )*( this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow())))+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by asics() method. */
  std::vector<int> asics_shape() const;
private:
  uint32_t	_version;
  uint32_t	_usePgpEvr;
  uint32_t	_evrRunCode;
  uint32_t	_evrDaqCode;
  uint32_t	_evrRunTrigDelay;
  uint32_t	_epixRunTrigDelay;
  uint32_t	_dacSetting;
  uint32_t	_asicPins;
  uint32_t	_asicControls;
  uint32_t	_acqToAsicR0Delay;
  uint32_t	_asicR0ToAsicAcq;
  uint32_t	_asicAcqWidth;
  uint32_t	_asicAcqLToPPmatL;
  uint32_t	_asicPPmatToReadout;
  uint32_t	_asicRoClkHalfT;
  uint32_t	_adcReadsPerPixel;
  uint32_t	_adcClkHalfT;
  uint32_t	_asicR0Width;
  uint32_t	_adcPipelineDelay;
  uint32_t	_adcPipelineDelay0;
  uint32_t	_adcPipelineDelay1;
  uint32_t	_adcPipelineDelay2;
  uint32_t	_adcPipelineDelay3;
  uint32_t	_Sync;	/**< new */
  uint32_t	_prepulseR0Width;
  uint32_t	_prepulseR0Delay;
  uint32_t	_digitalCardId0;
  uint32_t	_digitalCardId1;
  uint32_t	_analogCardId0;
  uint32_t	_analogCardId1;
  uint32_t	_carrierId0;
  uint32_t	_carrierId1;
  uint32_t	_numberOfAsicsPerRow;
  uint32_t	_numberOfAsicsPerColumn;
  uint32_t	_numberOfRowsPerAsic;
  uint32_t	_numberOfReadableRowsPerAsic;
  uint32_t	_numberOfPixelsPerAsicRow;	/**< for epix10ka  176 */
  uint32_t	_calibrationRowCountPerASIC;	/**< for epix10ka 96*4 = 384 */
  uint32_t	_environmentalRowCountPerASIC;
  uint32_t	_baseClockFrequency;
  uint32_t	_asicMask;
  uint32_t	_enableAutomaticRunTrigger;
  uint32_t	_numberOf125MhzTicksPerRunTrigger;
  uint32_t	_Scope;
  uint32_t	_ScopeTriggerParms_1;
  uint32_t	_ScopeTriggerParms_2;
  uint32_t	_ScopeWaveformSelects;
  //Epix::Asic10kaConfigV1	_asics[this->numberOfAsicsPerRow()*this->numberOfAsicsPerColumn()];
  //uint16_t	_asicPixelConfigArray[ this->numberOfRows()][ this->numberOfColumns()];
  //uint8_t	_calibPixelConfigArray[ this->numberOfCalibrationRows()  / 2 ][ this->numberOfPixelsPerAsicRow()*this->numberOfAsicsPerRow()];
};
#pragma pack(pop)

/** @class ElementV1


*/

class ConfigV1;
class Config10KV1;
#pragma pack(push,2)

class ElementV1 {
public:
  enum { TypeId = Pds::TypeId::Id_EpixElement /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  ElementV1() {}
private:
  ElementV1(const ElementV1&);
  ElementV1& operator=(const ElementV1&);
public:
  uint8_t vc() const { return uint8_t(this->_first & 0x3); }
  uint8_t lane() const { return uint8_t((this->_first>>6) & 0x3); }
  uint16_t acqCount() const { return uint16_t(this->_second & 0xffff); }
  uint32_t frameNumber() const { return _frameNumber; }
  uint32_t ticks() const { return _ticks; }
  uint32_t fiducials() const { return _fiducials; }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> frame(const Epix::ConfigV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=32;
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfRows(), cfg.numberOfColumns());
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> frame(const Epix::Config10KV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=32;
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfRows(), cfg.numberOfColumns());
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> frame(const GenericPgp::ConfigV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=32;
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfRows(), cfg.numberOfColumns());
//  }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> frame(const Epix::ConfigV1& cfg) const { ptrdiff_t offset=32;
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfRows(), cfg.numberOfColumns()); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> frame(const Epix::Config10KV1& cfg) const { ptrdiff_t offset=32;
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfRows(), cfg.numberOfColumns()); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> frame(const GenericPgp::ConfigV1& cfg) const { ptrdiff_t offset=32;
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfRows(), cfg.numberOfColumns()); }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> excludedRows(const Epix::ConfigV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns())));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.lastRowExclusions(), cfg.numberOfColumns());
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> excludedRows(const Epix::Config10KV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns())));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.lastRowExclusions(), cfg.numberOfColumns());
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> excludedRows(const GenericPgp::ConfigV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns())));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.lastRowExclusions(), cfg.numberOfColumns());
//  }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> excludedRows(const Epix::ConfigV1& cfg) const { ptrdiff_t offset=32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns())));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.lastRowExclusions(), cfg.numberOfColumns()); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> excludedRows(const Epix::Config10KV1& cfg) const { ptrdiff_t offset=32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns())));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.lastRowExclusions(), cfg.numberOfColumns()); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> excludedRows(const GenericPgp::ConfigV1& cfg) const { ptrdiff_t offset=32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns())));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.lastRowExclusions(), cfg.numberOfColumns()); }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 1> temperatures(const Epix::ConfigV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=(32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns()))))+(2*((cfg.lastRowExclusions())*(cfg.numberOfColumns())));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 1> temperatures(const Epix::Config10KV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=(32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns()))))+(2*((cfg.lastRowExclusions())*(cfg.numberOfColumns())));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 1> temperatures(const GenericPgp::ConfigV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=(32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns()))))+(2*((cfg.lastRowExclusions())*(cfg.numberOfColumns())));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
//  }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 1> temperatures(const Epix::ConfigV1& cfg) const { ptrdiff_t offset=(32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns()))))+(2*((cfg.lastRowExclusions())*(cfg.numberOfColumns())));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfAsics()); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 1> temperatures(const Epix::Config10KV1& cfg) const { ptrdiff_t offset=(32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns()))))+(2*((cfg.lastRowExclusions())*(cfg.numberOfColumns())));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfAsics()); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 1> temperatures(const GenericPgp::ConfigV1& cfg) const { ptrdiff_t offset=(32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns()))))+(2*((cfg.lastRowExclusions())*(cfg.numberOfColumns())));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfAsics()); }
  uint32_t lastWord(const Epix::ConfigV1& cfg) const { ptrdiff_t offset=((32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns()))))+(2*((cfg.lastRowExclusions())*(cfg.numberOfColumns()))))+(2*(cfg.numberOfAsics()));
  return *(const uint32_t*)(((const char*)this)+offset); }
  uint32_t lastWord(const Epix::Config10KV1& cfg) const { ptrdiff_t offset=((32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns()))))+(2*((cfg.lastRowExclusions())*(cfg.numberOfColumns()))))+(2*(cfg.numberOfAsics()));
  return *(const uint32_t*)(((const char*)this)+offset); }
//  uint32_t lastWord(const GenericPgp::ConfigV1& cfg) const { ptrdiff_t offset=((32+(2*((cfg.numberOfRows())*(cfg.numberOfColumns()))))+(2*((cfg.lastRowExclusions())*(cfg.numberOfColumns()))))+(2*(cfg.numberOfAsics()));
//  return *(const uint32_t*)(((const char*)this)+offset); }
  static uint32_t _sizeof(const Epix::ConfigV1& cfg) { return (((((((32+(2*(cfg.numberOfRows())*(cfg.numberOfColumns())))+(2*(cfg.lastRowExclusions())*(cfg.numberOfColumns())))+(2*(cfg.numberOfAsics())))+4)+2)-1)/2)*2; }
  static uint32_t _sizeof(const Epix::Config10KV1& cfg) { return (((((((32+(2*(cfg.numberOfRows())*(cfg.numberOfColumns())))+(2*(cfg.lastRowExclusions())*(cfg.numberOfColumns())))+(2*(cfg.numberOfAsics())))+4)+2)-1)/2)*2; }
//  static uint32_t _sizeof(const GenericPgp::ConfigV1& cfg) { return (((((((32+(2*(cfg.numberOfRows())*(cfg.numberOfColumns())))+(2*(cfg.lastRowExclusions())*(cfg.numberOfColumns())))+(2*(cfg.numberOfAsics())))+4)+2)-1)/2)*2; }
private:
  uint32_t	_first;
  uint32_t	_second;
  uint32_t	_frameNumber;
  uint32_t	_ticks;
  uint32_t	_fiducials;
  uint32_t	_z0;
  uint32_t	_z1;
  uint32_t	_z2;
  //uint16_t	_frame[cfg.numberOfRows()][cfg.numberOfColumns()];
  //uint16_t	_excludedRows[cfg.lastRowExclusions()][cfg.numberOfColumns()];
  //uint16_t	_temperatures[cfg.numberOfAsics()];
  //uint32_t	_lastWord;
};
#pragma pack(pop)

/** @class ElementV2


*/

class Config100aV1;
class Config100aV2;
class ConfigSV1;
#pragma pack(push,2)

class ElementV2 {
public:
  enum { TypeId = Pds::TypeId::Id_EpixElement /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  ElementV2() {}
private:
  ElementV2(const ElementV2&);
  ElementV2& operator=(const ElementV2&);
public:
  uint8_t vc() const { return uint8_t(this->_first & 0x3); }
  uint8_t lane() const { return uint8_t((this->_first>>6) & 0x3); }
  uint16_t acqCount() const { return uint16_t(this->_second & 0xffff); }
  uint32_t frameNumber() const { return _frameNumber; }
  uint32_t ticks() const { return _ticks; }
  uint32_t fiducials() const { return _fiducials; }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> frame(const Epix::Config100aV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=32;
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfReadableRows(), cfg.numberOfColumns());
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> frame(const Epix::Config100aV2& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=32;
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfReadableRows(), cfg.numberOfColumns());
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> frame(const Epix::ConfigSV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=32;
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfReadableRows(), cfg.numberOfColumns());
//  }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> frame(const Epix::Config100aV1& cfg) const { ptrdiff_t offset=32;
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfReadableRows(), cfg.numberOfColumns()); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> frame(const Epix::Config100aV2& cfg) const { ptrdiff_t offset=32;
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfReadableRows(), cfg.numberOfColumns()); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> frame(const Epix::ConfigSV1& cfg) const { ptrdiff_t offset=32;
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfReadableRows(), cfg.numberOfColumns()); }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> calibrationRows(const Epix::Config100aV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfCalibrationRows(), cfg.numberOfColumns());
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> calibrationRows(const Epix::Config100aV2& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfCalibrationRows(), cfg.numberOfColumns());
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> calibrationRows(const Epix::ConfigSV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfCalibrationRows(), cfg.numberOfColumns());
//  }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> calibrationRows(const Epix::Config100aV1& cfg) const { ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfCalibrationRows(), cfg.numberOfColumns()); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> calibrationRows(const Epix::Config100aV2& cfg) const { ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfCalibrationRows(), cfg.numberOfColumns()); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> calibrationRows(const Epix::ConfigSV1& cfg) const { ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfCalibrationRows(), cfg.numberOfColumns()); }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> environmentalRows(const Epix::Config100aV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns());
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> environmentalRows(const Epix::Config100aV2& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns());
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> environmentalRows(const Epix::ConfigSV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns());
//  }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> environmentalRows(const Epix::Config100aV1& cfg) const { ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> environmentalRows(const Epix::Config100aV2& cfg) const { ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> environmentalRows(const Epix::ConfigSV1& cfg) const { ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()); }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 1> temperatures(const Epix::Config100aV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns())));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 1> temperatures(const Epix::Config100aV2& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns())));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 1> temperatures(const Epix::ConfigSV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns())));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
//  }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 1> temperatures(const Epix::Config100aV1& cfg) const { ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns())));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfAsics()); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 1> temperatures(const Epix::Config100aV2& cfg) const { ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns())));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfAsics()); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 1> temperatures(const Epix::ConfigSV1& cfg) const { ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns())));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfAsics()); }
  uint32_t lastWord(const Epix::Config100aV1& cfg) const { ptrdiff_t offset=(((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()))))+(2*(cfg.numberOfAsics()));
  return *(const uint32_t*)(((const char*)this)+offset); }
  uint32_t lastWord(const Epix::Config100aV2& cfg) const { ptrdiff_t offset=(((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()))))+(2*(cfg.numberOfAsics()));
  return *(const uint32_t*)(((const char*)this)+offset); }
  uint32_t lastWord(const Epix::ConfigSV1& cfg) const { ptrdiff_t offset=(((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()))))+(2*(cfg.numberOfAsics()));
  return *(const uint32_t*)(((const char*)this)+offset); }
  static uint32_t _sizeof(const Epix::Config100aV1& cfg) { return ((((((((32+(2*(cfg.numberOfReadableRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfAsics())))+4)+2)-1)/2)*2; }
  static uint32_t _sizeof(const Epix::Config100aV2& cfg) { return ((((((((32+(2*(cfg.numberOfReadableRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfAsics())))+4)+2)-1)/2)*2; }
  static uint32_t _sizeof(const Epix::ConfigSV1& cfg) { return ((((((((32+(2*(cfg.numberOfReadableRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfAsics())))+4)+2)-1)/2)*2; }
private:
  uint32_t	_first;
  uint32_t	_second;
  uint32_t	_frameNumber;
  uint32_t	_ticks;
  uint32_t	_fiducials;
  uint32_t	_z0;
  uint32_t	_z1;
  uint32_t	_z2;
  //uint16_t	_frame[cfg.numberOfReadableRows()][cfg.numberOfColumns()];
  //uint16_t	_calibrationRows[cfg.numberOfCalibrationRows()][cfg.numberOfColumns()];
  //uint16_t	_environmentalRows[cfg.numberOfEnvironmentalRows()][cfg.numberOfColumns()];
  //uint16_t	_temperatures[cfg.numberOfAsics()];
  //uint32_t	_lastWord;
};
#pragma pack(pop)

/** @class ElementV3


*/

class Config100aV1;
class Config100aV2;
class ConfigSV1;
class Config10kaV1;
#pragma pack(push,2)

class ElementV3 {
public:
  enum { TypeId = Pds::TypeId::Id_EpixElement /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 3 /**< XTC type version number */ };
  ElementV3() {}
private:
  ElementV3(const ElementV3&);
  ElementV3& operator=(const ElementV3&);
public:
  uint8_t vc() const { return uint8_t(this->_first & 0x3); }
  uint8_t lane() const { return uint8_t((this->_first>>6) & 0x3); }
  uint16_t acqCount() const { return uint16_t(this->_second & 0xffff); }
  uint32_t frameNumber() const { return _frameNumber; }
  uint32_t ticks() const { return _ticks; }
  uint32_t fiducials() const { return _fiducials; }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> frame(const Epix::Config100aV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=32;
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfReadableRows(), cfg.numberOfColumns());
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> frame(const Epix::Config100aV2& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=32;
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfReadableRows(), cfg.numberOfColumns());
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> frame(const Epix::ConfigSV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=32;
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfReadableRows(), cfg.numberOfColumns());
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> frame(const Epix::Config10kaV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=32;
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfReadableRows(), cfg.numberOfColumns());
//  }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> frame(const Epix::Config100aV1& cfg) const { ptrdiff_t offset=32;
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfReadableRows(), cfg.numberOfColumns()); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> frame(const Epix::Config100aV2& cfg) const { ptrdiff_t offset=32;
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfReadableRows(), cfg.numberOfColumns()); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> frame(const Epix::ConfigSV1& cfg) const { ptrdiff_t offset=32;
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfReadableRows(), cfg.numberOfColumns()); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> frame(const Epix::Config10kaV1& cfg) const { ptrdiff_t offset=32;
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfReadableRows(), cfg.numberOfColumns()); }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> calibrationRows(const Epix::Config100aV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfCalibrationRows(), cfg.numberOfColumns());
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> calibrationRows(const Epix::Config100aV2& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfCalibrationRows(), cfg.numberOfColumns());
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> calibrationRows(const Epix::ConfigSV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfCalibrationRows(), cfg.numberOfColumns());
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 2> calibrationRows(const Epix::Config10kaV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfCalibrationRows(), cfg.numberOfColumns());
//  }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> calibrationRows(const Epix::Config100aV1& cfg) const { ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfCalibrationRows(), cfg.numberOfColumns()); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> calibrationRows(const Epix::Config100aV2& cfg) const { ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfCalibrationRows(), cfg.numberOfColumns()); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> calibrationRows(const Epix::ConfigSV1& cfg) const { ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfCalibrationRows(), cfg.numberOfColumns()); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 2> calibrationRows(const Epix::Config10kaV1& cfg) const { ptrdiff_t offset=32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns())));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfCalibrationRows(), cfg.numberOfColumns()); }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint32_t, 2> environmentalRows(const Epix::Config100aV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
//    const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1);
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint32_t, 2> environmentalRows(const Epix::Config100aV2& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
//    const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1);
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint32_t, 2> environmentalRows(const Epix::ConfigSV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
//    const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1);
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint32_t, 2> environmentalRows(const Epix::Config10kaV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
//    const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1);
//  }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint32_t, 2> environmentalRows(const Epix::Config100aV1& cfg) const { ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
//  const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint32_t, 2> environmentalRows(const Epix::Config100aV2& cfg) const { ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
//  const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint32_t, 2> environmentalRows(const Epix::ConfigSV1& cfg) const { ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
//  const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint32_t, 2> environmentalRows(const Epix::Config10kaV1& cfg) const { ptrdiff_t offset=(32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())));
//  const uint32_t* data = (const uint32_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfEnvironmentalRows(), cfg.numberOfColumns()>>1); }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 1> temperatures(const Epix::Config100aV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 1> temperatures(const Epix::Config100aV2& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 1> temperatures(const Epix::ConfigSV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 1> temperatures(const Epix::Config10kaV1& cfg, const boost::shared_ptr<T>& owner) const {
//    ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)));
//    const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), cfg.numberOfAsics());
//  }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 1> temperatures(const Epix::Config100aV1& cfg) const { ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfAsics()); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 1> temperatures(const Epix::Config100aV2& cfg) const { ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfAsics()); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 1> temperatures(const Epix::ConfigSV1& cfg) const { ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfAsics()); }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 1> temperatures(const Epix::Config10kaV1& cfg) const { ptrdiff_t offset=((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)));
//  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
//  return make_ndarray(data, cfg.numberOfAsics()); }
  uint32_t lastWord(const Epix::Config100aV1& cfg) const { ptrdiff_t offset=(((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1))))+(2*(cfg.numberOfAsics()));
  return *(const uint32_t*)(((const char*)this)+offset); }
  uint32_t lastWord(const Epix::Config100aV2& cfg) const { ptrdiff_t offset=(((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1))))+(2*(cfg.numberOfAsics()));
  return *(const uint32_t*)(((const char*)this)+offset); }
  uint32_t lastWord(const Epix::ConfigSV1& cfg) const { ptrdiff_t offset=(((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1))))+(2*(cfg.numberOfAsics()));
  return *(const uint32_t*)(((const char*)this)+offset); }
  uint32_t lastWord(const Epix::Config10kaV1& cfg) const { ptrdiff_t offset=(((32+(2*((cfg.numberOfReadableRows())*(cfg.numberOfColumns()))))+(2*((cfg.numberOfCalibrationRows())*(cfg.numberOfColumns()))))+(4*((cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1))))+(2*(cfg.numberOfAsics()));
  return *(const uint32_t*)(((const char*)this)+offset); }
  static uint32_t _sizeof(const Epix::Config100aV1& cfg) { return ((((((((32+(2*(cfg.numberOfReadableRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())))+(4*(cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)))+(2*(cfg.numberOfAsics())))+4)+2)-1)/2)*2; }
  static uint32_t _sizeof(const Epix::Config100aV2& cfg) { return ((((((((32+(2*(cfg.numberOfReadableRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())))+(4*(cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)))+(2*(cfg.numberOfAsics())))+4)+2)-1)/2)*2; }
  static uint32_t _sizeof(const Epix::ConfigSV1& cfg) { return ((((((((32+(2*(cfg.numberOfReadableRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())))+(4*(cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)))+(2*(cfg.numberOfAsics())))+4)+2)-1)/2)*2; }
  static uint32_t _sizeof(const Epix::Config10kaV1& cfg) { return ((((((((32+(2*(cfg.numberOfReadableRows())*(cfg.numberOfColumns())))+(2*(cfg.numberOfCalibrationRows())*(cfg.numberOfColumns())))+(4*(cfg.numberOfEnvironmentalRows())*(cfg.numberOfColumns()>>1)))+(2*(cfg.numberOfAsics())))+4)+2)-1)/2)*2; }
private:
  uint32_t	_first;
  uint32_t	_second;
  uint32_t	_frameNumber;
  uint32_t	_ticks;
  uint32_t	_fiducials;
  uint32_t	_z0;
  uint32_t	_z1;
  uint32_t	_z2;
  //uint16_t	_frame[cfg.numberOfReadableRows()][cfg.numberOfColumns()];
  //uint16_t	_calibrationRows[cfg.numberOfCalibrationRows()][cfg.numberOfColumns()];
  //uint32_t	_environmentalRows[cfg.numberOfEnvironmentalRows()][cfg.numberOfColumns()>>1];
  //uint16_t	_temperatures[cfg.numberOfAsics()];
  //uint32_t	_lastWord;
};
#pragma pack(pop)
} // namespace Epix
} // namespace Pds
#endif // PDS_EPIX_DDL_H
