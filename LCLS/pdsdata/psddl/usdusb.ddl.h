#ifndef PDS_USDUSB_DDL_H
#define PDS_USDUSB_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstddef>
#include <cstring>
#include "pdsdata/xtc/TypeId.hh"
//#include "ndarray/ndarray.h"
namespace Pds {
namespace UsdUsb {

/** @class FexConfigV1

  Class for creating a FexData for an encoder - takes an offset and scale.
*/


class FexConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_UsdUsbFexConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { NCHANNELS = 4 };
  enum { NAME_CHAR_MAX = 48 };
//  FexConfigV1(const int32_t* arg__offset, const double* arg__scale, const char* arg__name)
//  {
//    if (arg__offset) std::copy(arg__offset, arg__offset+(4), &_offset[0]);
//    if (arg__scale) std::copy(arg__scale, arg__scale+(4), &_scale[0]);
//    if (arg__name) std::copy(arg__name, arg__name+(192), &_name[0][0]);
//  }
//  FexConfigV1() {}
//  FexConfigV1(const FexConfigV1& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//  }
//  FexConfigV1& operator=(const FexConfigV1& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//    return *this;
//  }
//  /** Offset (in counts) to apply to raw encoder counts
//
//    Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const int32_t, 1> offset(const boost::shared_ptr<T>& owner) const {
//    const int32_t* data = &_offset[0];
//    return make_ndarray(boost::shared_ptr<const int32_t>(owner, data), NCHANNELS);
//  }
//  /** Offset (in counts) to apply to raw encoder counts
//
//    Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const int32_t, 1> offset() const { return make_ndarray(&_offset[0], NCHANNELS); }
//  /** Scale factor for converting encoder counts to units
//
//    Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const double, 1> scale(const boost::shared_ptr<T>& owner) const {
//    const double* data = &_scale[0];
//    return make_ndarray(boost::shared_ptr<const double>(owner, data), NCHANNELS);
//  }
//  /** Scale factor for converting encoder counts to units
//
//    Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const double, 1> scale() const { return make_ndarray(&_scale[0], NCHANNELS); }
//  /** Descriptive name for each channel */
//  const char* name(uint32_t i0) const { return _name[i0]; }
  static uint32_t _sizeof() { return ((((((0+(4*(NCHANNELS)))+(8*(NCHANNELS)))+(1*(NCHANNELS)*(NAME_CHAR_MAX)))+8)-1)/8)*8; }
//  /** Method which returns the shape (dimensions) of the data returned by name() method. */
//  std::vector<int> name_shape() const;
//private:
  int32_t	_offset[NCHANNELS];	/**< Offset (in counts) to apply to raw encoder counts */
  double	_scale[NCHANNELS];	/**< Scale factor for converting encoder counts to units */
  char	_name[NCHANNELS][NAME_CHAR_MAX];	/**< Descriptive name for each channel */
};

/** @class FexDataV1

  Class for holding the encoder value after application of an offset and scale.
*/


class FexDataV1 {
public:
  enum { TypeId = Pds::TypeId::Id_UsdUsbFexData /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { Encoder_Inputs = 4 };
//  FexDataV1(const double* arg__encoder_value)
//  {
//    if (arg__encoder_value) std::copy(arg__encoder_value, arg__encoder_value+(4), &_encoder_value[0]);
//  }
//  FexDataV1() {}
//  FexDataV1(const FexDataV1& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//  }
//  FexDataV1& operator=(const FexDataV1& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//    return *this;
//  }
//  /** Corrected encoder value = (raw_count + offset) * scale
//
//    Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const double, 1> encoder_values(const boost::shared_ptr<T>& owner) const {
//    const double* data = &_encoder_value[0];
//    return make_ndarray(boost::shared_ptr<const double>(owner, data), Encoder_Inputs);
//  }
//  /** Corrected encoder value = (raw_count + offset) * scale
//
//    Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const double, 1> encoder_values() const { return make_ndarray(&_encoder_value[0], Encoder_Inputs); }
  static uint32_t _sizeof() { return ((((0+(8*(Encoder_Inputs)))+8)-1)/8)*8; }
//private:
  double	_encoder_value[Encoder_Inputs];	/**< Corrected encoder value = (raw_count + offset) * scale */
};

/** @class ConfigV1


*/


class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_UsdUsbConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { NCHANNELS = 4 };
  enum Count_Mode {
    WRAP_FULL,
    LIMIT,
    HALT,
    WRAP_PRESET,
  };
  enum Quad_Mode {
    CLOCK_DIR,
    X1,
    X2,
    X4,
  };
//  ConfigV1(const UsdUsb::ConfigV1::Count_Mode* arg__count_mode, const UsdUsb::ConfigV1::Quad_Mode* arg__quad_mode)
//  {
//    if (arg__count_mode) std::copy(arg__count_mode, arg__count_mode+(4), &_count_mode[0]);
//    if (arg__quad_mode) std::copy(arg__quad_mode, arg__quad_mode+(4), &_quad_mode[0]);
//  }
//  ConfigV1() {}
//  ConfigV1(const ConfigV1& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//  }
//  ConfigV1& operator=(const ConfigV1& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//    return *this;
//  }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint32_t, 1> counting_mode(const boost::shared_ptr<T>& owner) const {
//    const uint32_t* data = &_count_mode[0];
//    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), NCHANNELS);
//  }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint32_t, 1> counting_mode() const { return make_ndarray(&_count_mode[0], NCHANNELS); }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint32_t, 1> quadrature_mode(const boost::shared_ptr<T>& owner) const {
//    const uint32_t* data = &_quad_mode[0];
//    return make_ndarray(boost::shared_ptr<const uint32_t>(owner, data), NCHANNELS);
//  }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint32_t, 1> quadrature_mode() const { return make_ndarray(&_quad_mode[0], NCHANNELS); }
  static uint32_t _sizeof() { return (((((0+(4*(NCHANNELS)))+(4*(NCHANNELS)))+4)-1)/4)*4; }
//private:
  uint32_t	_count_mode[NCHANNELS];
  uint32_t	_quad_mode[NCHANNELS];
};
//std::ostream& operator<<(std::ostream& str, UsdUsb::ConfigV1::Count_Mode enval);
//std::ostream& operator<<(std::ostream& str, UsdUsb::ConfigV1::Quad_Mode enval);

/** @class DataV1


*/


class DataV1 {
public:
  enum { TypeId = Pds::TypeId::Id_UsdUsbData /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { Encoder_Inputs = 4 };
  enum { Analog_Inputs = 4 };
  enum { Digital_Inputs = 8 };
//  DataV1() {}
//  DataV1(const DataV1& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//  }
//  DataV1& operator=(const DataV1& other) {
//    const char* src = reinterpret_cast<const char*>(&other);
//    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
//    return *this;
//  }
//  uint8_t digital_in() const { return _din; }
//  uint32_t timestamp() const { return _timestamp; }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint8_t, 1> status(const boost::shared_ptr<T>& owner) const {
//    const uint8_t* data = &_status[0];
//    return make_ndarray(boost::shared_ptr<const uint8_t>(owner, data), 4);
//  }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint8_t, 1> status() const { return make_ndarray(&_status[0], 4); }
//  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
//    this instance, the returned ndarray object can be used even after this instance disappears. */
//  template <typename T>
//  ndarray<const uint16_t, 1> analog_in(const boost::shared_ptr<T>& owner) const {
//    const uint16_t* data = &_ain[0];
//    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), Analog_Inputs);
//  }
//  /**     Note: this method returns ndarray instance which does not control lifetime
//    of the data, do not use returned ndarray after this instance disappears. */
//  ndarray<const uint16_t, 1> analog_in() const { return make_ndarray(&_ain[0], Analog_Inputs); }
//  /** Return lower 24 bits of _count array as signed integer values. */
//  ndarray<const int32_t, 1> encoder_count() const;
  static uint32_t _sizeof() { return ((((((((((0+(1*(6)))+1)+1)+4)+(4*(Encoder_Inputs)))+(1*(4)))+(2*(Analog_Inputs)))+4)-1)/4)*4; }
//private:
  uint8_t	_header[6];
  uint8_t	_din;
  uint8_t	_estop;
  uint32_t	_timestamp;
  uint32_t	_count[Encoder_Inputs];
  uint8_t	_status[4];
  uint16_t	_ain[Analog_Inputs];
};
} // namespace UsdUsb
} // namespace Pds
#endif // PDS_USDUSB_DDL_H
