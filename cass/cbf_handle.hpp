//Copyright (C) 2012 Lutz Foucar

/**
 * @file cbf_handle.hpp handle cbf files
 *
 * @author Lutz Foucar
 */

#ifndef _CBFHANDLE_
#define _CBFHANDLE_

#include <QtCore/QString>
#include <QtCore/QFileInfo>

#include <vector>
#include <string>
#include <fstream>
#include <sstream>

#include "cass_version.h"

namespace cass
{
namespace CBF
{
/** write cbf file
 *
 * @param filename the filename to write the cbf to
 * @param data the data that should be written
 * @param shape the shape of the image
 *
 * @author Stephan Kassemeyer
 */
inline
void write(const std::string &filename, const std::vector<float> &data,
           const std::pair<int,int>& shape)
{
  const int nx = shape.first;
  const int ny = shape.second;

  /** cbf parameters: */
  int IOBUFSIZ = 4096;
  char MARKBYTE[4] = {static_cast<char>(0x0C),
                      static_cast<char>(0x01A),
                      static_cast<char>(0x004),
                      static_cast<char>(0x0D5)};

  /** create the cbf file */
  std::ofstream cbf_file;
  cbf_file.open(filename.c_str(), std::ios::out|std::ios::binary);

  /**  find out length of the compressed array: */
  int nbytes = 0;
  int pixvalue = 0;
  int diff;
  int absdiff;
  for (int iadr=0; iadr<nx*ny; ++iadr)
  {
    diff = ((int) data[iadr]) - pixvalue;
    pixvalue = (int) data[iadr];
    absdiff = abs(diff);
    ++nbytes;
    if (absdiff < 128)
      continue;
    nbytes += 2;
    if (absdiff < 32768)
      continue;
    nbytes += 4;
  }

  QString fn(QString::fromStdString(filename));
  QString bn(QFileInfo(fn).fileName());
  std::string fbn(bn.toStdString());

  /** write image header */
  cbf_file << "###CBF: Generated by CASS " << VERSION << "\r\n";
  cbf_file << "" << "\r\n";
  cbf_file << fbn << "\r\n";
  cbf_file << "" << "\r\n";
  cbf_file << "_array_data.header_convention \"XDS special\"" << "\r\n";
  cbf_file << "_array_data.header_contents" << "\r\n";
  cbf_file << ";" << "\r\n";
  cbf_file << ";" << "\r\n";
  cbf_file << "" << "\r\n";
  cbf_file << "_array_data.data" << "\r\n";
  cbf_file << ";" << "\r\n";
  cbf_file << "--CIF-BINARY-FORMAT-SECTION--" << "\r\n";
  cbf_file << "Content-Type: application/octet-stream;" << "\r\n";
  cbf_file << "     conversions=\"x-CBF_BYTE_OFFSET\"" << "\r\n";
  cbf_file << "Content-Transfer-Encoding: BINARY" << "\r\n";
  cbf_file << "X-Binary-Size:" << nbytes << "\r\n";
  cbf_file << "X-Binary-ID: 1" << "\r\n";
  cbf_file << "X-Binary-Element-Type: \"signed 32-bit integer\"" << "\r\n";
  cbf_file << "X-Binary-Element-Byte-Order: LITTLE_ENDIAN" << "\r\n";
  cbf_file << "X-Binary-Number-of-Elements: " << nx*ny << "\r\n";
  cbf_file << "X-Binary-Size-Fastest-Dimension: " << nx << "\r\n";
  cbf_file << "X-Binary-Size-Second-Dimension: " << ny << "\r\n";
  cbf_file << "X-Binary-Size-Padding: " << IOBUFSIZ-1 << "\r\n";
  cbf_file << "" << "\r\n";
  cbf_file << MARKBYTE[0] << MARKBYTE[1] << MARKBYTE[2] << MARKBYTE[3];


  // determine endianness
  int step, first2, last2, first4, last4;
  union
  {
    uint32_t ii;
    char cc[4];
  }
  bint = {0x01020304};
  if (bint.cc[0] == 1)
  {
    // big endian
    step = -1;
    first2=1; last2=0;
    first4=3; last4=0;
  }
  else
  {
    // little endian
    step = 1;
    first2=0; last2=1;
    first4=0; last4=3;
  }

  /** write histogram data
   * compress image using the byte offset method and save as octet stream
   */
  pixvalue = 0;

  signed char onebyte[1];
  signed char twobytes[2];
  signed char fourbytes[4];
  int shortint;

  for (int iadr=0; iadr<nx*ny; ++iadr)
  {
    diff = ((int) data[iadr]) - pixvalue;
    absdiff = abs(diff);
    pixvalue = (int)data[iadr];

    onebyte[0] = -128;
    if (absdiff < 128)
      onebyte[0] = diff;
    cbf_file << onebyte[0];
    if (absdiff < 128)
      continue;

    shortint = -32768;
    if (absdiff < 32768)
      shortint = diff;
    *((char*)(&twobytes)+0) = *((char*)(&shortint)+0);
    *((char*)(&twobytes)+1) = *((char*)(&shortint)+1);

    for (int ii=first2; ii!=last2+step; ii+=step)
      cbf_file << twobytes[ii];
    if (absdiff < 32768)
      continue;

    *((char*)(&fourbytes)+0) = *((char*)(&diff)+0);
    *((char*)(&fourbytes)+1) = *((char*)(&diff)+1);
    *((char*)(&fourbytes)+2) = *((char*)(&diff)+2);
    *((char*)(&fourbytes)+3) = *((char*)(&diff)+3);

    for (int ii=first4; ii!=last4+step; ii+=step)
      cbf_file << fourbytes[ii];
  }

  /** terminate image data part and pad last record of file with zeros:*/
  cbf_file << "--CIF-BINARY-FORMAT-SECTION----";
  cbf_file << ";";

  char zerobyte;
  zerobyte = 0;
  for (int ii=0; ii<IOBUFSIZ; ++ii)
    cbf_file << zerobyte;

  cbf_file.close();
}

/** read the cbf data into a linearized 2d array
 *
 * @param[in] filename the name of the cbf file to read
 * @param[out] headerstring the complete header of the cbf file
 * @param[out] matrix the output matrix, will be resized to fit the data
 * @param[out] shape the shape of the matrix
 */
void read(const std::string & filename, std::string &headerstring,
          std::vector<float>& matrix, std::pair<int,int>& shape)
{
  /** open file and determine filesize */
  std::ifstream cbf_file(filename.c_str(), std::ios::in | std::ios::binary);
  cbf_file.seekg(0,std::ios::end);
  std::streampos fsize(cbf_file.tellg());
  cbf_file.seekg(0,std::ios::beg);


  /** create a buffer and copy the whole header to it */
  bool eohfound=false;
  std::vector<char> header(fsize);
  std::vector<uint8_t> eohMarker(4,0);
  int hidx(0);
  while (!cbf_file.eof())
  {
    cbf_file.read(reinterpret_cast<char*>(&eohMarker[0]),1);

    if (eohMarker[0] == 0x0C)
    {
      cbf_file.read(reinterpret_cast<char*>(&eohMarker[1]),1);
      cbf_file.read(reinterpret_cast<char*>(&eohMarker[2]),1);
      cbf_file.read(reinterpret_cast<char*>(&eohMarker[3]),1);
      if (eohMarker[1] == 0x1A && eohMarker[2] == 0x04 && eohMarker[3] == 0xD5)
      {
        eohfound = true;
        break;
      }
    }

    header[hidx++] = eohMarker[0];
  }
  if (!eohfound)
    throw std::invalid_argument(filename + " is not a cbf file");


  /** parse the header */
  headerstring.assign(header.begin(),header.begin()+hidx);
  std::istringstream headerstream(headerstring);
  while(!headerstream.eof())
  {
    std::string line;
    std::getline(headerstream,line);

    if (line.find("X-Binary-Size-Fastest-Dimension:") != std::string::npos)
    {
      std::istringstream iss(line);
      std::vector<std::string> tokens;
      std::string token;
      while(std::getline(iss,token,' '))
        tokens.push_back(token);
      shape.first = atoi(tokens.back().c_str());
    }

    if (line.find("X-Binary-Size-Second-Dimension:") != std::string::npos)
    {
      std::istringstream iss(line);
      std::vector<std::string> tokens;
      std::string token;
      while(std::getline(iss,token,' '))
        tokens.push_back(token);
      shape.second = atoi(tokens.back().c_str());
    }
  }

  /** read the matrix data */
  matrix.resize(shape.first*shape.second);
  int cInd = 0;
  int8_t onebyte = 0;
  int16_t twobytes = 0;
  int32_t fourbytes = 0;
  float cVal = 0;
  while (!cbf_file.eof() && cInd < shape.first * shape.second)
  {
    cbf_file.read(reinterpret_cast<char*>(&onebyte),1);
    if (onebyte == -128)
    {
      cbf_file.read(reinterpret_cast<char *>(&twobytes),2);
      if (twobytes == -32768)
      {
        cbf_file.read(reinterpret_cast<char *>(&fourbytes),4);
        cVal += fourbytes;
      }
      else
        cVal += twobytes;
    }
    else
      cVal += onebyte;
    matrix[cInd] = cVal;
    ++cInd;
  }
}

}//end namespace cbf
}//end namespace cass

#endif
